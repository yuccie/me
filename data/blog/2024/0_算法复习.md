---
title: '算法复习'
date: Mon Dec 23 2024 21:09:19 GMT+0800 (中国标准时间)
lastmod: '2024-12-23'
tags: ['数据结构', '算法']
draft: false
summary: '算法与数据结构'
layout: PostSimple
bibliography: references-data.bib
canonicalUrl: https://dume.vercel.app/blog/2024/0_算法复习.md
---

## 算法

### 深拷贝

```js
const complexObject = {
  number: 42,
  string: 'Hello, World!',
  boolean: true,
  nullValue: null,
  undefinedValue: undefined,
  symbol: Symbol('mySymbol'),
  array: [1, 2, 3, 'a', 'b', 'c'],
  object: {
    nestedNumber: 100,
    nestedString: 'nested string',
  },
  functionValue: function () {
    console.log('This is a function')
  },
  regexp: /test/gi,
  date: new Date(),
  error: new Error('This is an error'),
  map: new Map([
    ['key1', 'value1'],
    ['key2', 'value2'],
  ]),
  set: new Set([5, 10, 15, 20]),
  weakMap: new WeakMap([
    [{ key: 'weakKey1' }, 'value1'],
    [{ key: 'weakKey2' }, 'value2'],
  ]),
  weakSet: new WeakSet([{ key: 'weakSetKey1' }, { key: 'weakSetKey2' }]),

  // 循环引用
  selfReference: null,
}

// 设置循环引用
complexObject.selfReference = complexObject

const deepClone = (target) => {
  const isWhat = (v) => Object.prototype.toString.call(v).slice(8, -1)
  const cWeakMap = new WeakMap()

  const _deep = (data) => {
    if (isWhat(data) === 'Date') return new Date(data)

    if (!['Array', 'Object'].includes(isWhat(data))) return data

    if (cWeakMap.has(data)) return cWeakMap.get(data)

    const res = Array.isArray(data) ? [] : {}

    cWeakMap.set(data, res)

    Object.keys(data).forEach((k, v) => {
      if (res[k]) return
      res[k] = _deep(data[k])
    })

    return res
  }

  return _deep(target)
}

console.log(deepClone(complexObject))
```

### x 的 n 次方

- 很容易想到，一个数的正 n 次方，遍历相乘即可
- 但丢失了 0、负数的场景
- 同时算法的复杂度是，O(n)

```js
const xFn = (x, n) => {
  let res = 1 // 初始值是1
  while (n-- > 0) {
    res = res * x
  }
  return res
}
console.log(xFn(2, 3)) // 8
```

修复上面的问题

```js
const xFnPro = (x, n) => {
  // 如果是0、负数、整数
  if (n === 0) return 1
  // 如果是负数，则取倒数
  if (n < 0) {
    return 1 / xFnPro(x, -n)
  }

  if (n % 2) {
    return x * xFnPro(x, n - 1)
  }

  // 当是偶数时，比如 2^4，常规需要乘四次，变个思路就需要乘两次了
  // 如 xFnPro(2 * 2, 4 / 2) 只需要乘两次，从而降低运算次数，也就是降低了复杂度
  // 最终复杂度是 O(logn) 相比O(n) 确实小不少
  return xFnPro(x * x, n / 2)
}

console.log(xFnPro(2, -2)) // 0.25
console.log(xFnPro(2, 0)) // 1
console.log(xFnPro(2, 2)) // 4
```
