---
title: '算法复习'
date: Mon Dec 23 2024 21:09:19 GMT+0800 (中国标准时间)
lastmod: '2024-12-23'
tags: ['数据结构', '算法']
draft: false
summary: '算法与数据结构'
layout: PostSimple
bibliography: references-data.bib
canonicalUrl: https://dume.vercel.app/blog/2024/0_算法复习.md
---

## 算法

### 深拷贝

```js
const complexObject = {
  number: 42,
  string: 'Hello, World!',
  boolean: true,
  nullValue: null,
  undefinedValue: undefined,
  symbol: Symbol('mySymbol'),
  array: [1, 2, 3, 'a', 'b', 'c'],
  object: {
    nestedNumber: 100,
    nestedString: 'nested string',
  },
  functionValue: function () {
    console.log('This is a function')
  },
  regexp: /test/gi,
  date: new Date(),
  error: new Error('This is an error'),
  map: new Map([
    ['key1', 'value1'],
    ['key2', 'value2'],
  ]),
  set: new Set([5, 10, 15, 20]),
  weakMap: new WeakMap([
    [{ key: 'weakKey1' }, 'value1'],
    [{ key: 'weakKey2' }, 'value2'],
  ]),
  weakSet: new WeakSet([{ key: 'weakSetKey1' }, { key: 'weakSetKey2' }]),

  // 循环引用
  selfReference: null,
}

// 设置循环引用
complexObject.selfReference = complexObject

const deepClone = (target) => {
  const isWhat = (v) => Object.prototype.toString.call(v).slice(8, -1)
  const cWeakMap = new WeakMap()

  const _deep = (data) => {
    if (isWhat(data) === 'Date') return new Date(data)

    if (!['Array', 'Object'].includes(isWhat(data))) return data

    if (cWeakMap.has(data)) return cWeakMap.get(data)

    const res = Array.isArray(data) ? [] : {}

    cWeakMap.set(data, res)

    Object.keys(data).forEach((k, v) => {
      if (res[k]) return
      res[k] = _deep(data[k])
    })

    return res
  }

  return _deep(target)
}

console.log(deepClone(complexObject))
```

### x 的 n 次方

- 很容易想到，一个数的正 n 次方，遍历相乘即可
- 但丢失了 0、负数的场景
- 同时算法的复杂度是，O(n)

```js
const xFn = (x, n) => {
  let res = 1 // 初始值是1
  while (n-- > 0) {
    res = res * x
  }
  return res
}
console.log(xFn(2, 3)) // 8
```

修复上面的问题

```js
const xFnPro = (x, n) => {
  // 如果是0、负数、整数
  if (n === 0) return 1
  // 如果是负数，则取倒数
  if (n < 0) {
    return 1 / xFnPro(x, -n)
  }

  if (n % 2) {
    return x * xFnPro(x, n - 1)
  }

  // 当是偶数时，比如 2^4，常规需要乘四次，变个思路就需要乘两次了
  // 如 xFnPro(2 * 2, 4 / 2) 只需要乘两次，从而降低运算次数，也就是降低了复杂度
  // 最终复杂度是 O(logn) 相比O(n) 确实小不少
  return xFnPro(x * x, n / 2)
}

console.log(xFnPro(2, -2)) // 0.25
console.log(xFnPro(2, 0)) // 1
console.log(xFnPro(2, 2)) // 4
```

### 判断循环引用

只需要用一个对象，记录访问过的对象即可，类似深拷贝中的 weakMap，但需要注意 weakMap 的入参以及退出条件

```js
const hasCircleRefercence = (obj, seen = new WeakMap()) => {
  // 简单数据类型，不可能发生引用
  // 数据类型是大写，因为weakMap的key是对象，因此还不能简单的判断 ['Null', 'Undefined', 'String']
  // if (['Null', 'Undefined', 'String'].includes(isWhat(obj))) return false
  if (!['Object', 'Array'].includes(isWhat(obj))) return false

  if (seen.has(obj)) return true

  // 将这个对象设置为访问过的状态
  seen.set(obj, true)

  // 遍历对象内部的各个值
  // 还需要针对数组和对象进行遍历
  // if (['Array', 'Object'].includes(isWhat(obj))) {
  for (const key of Object.keys(obj)) {
    // 这里不要忘记传入 seen
    if (hasCircleRefercence(obj[key], seen)) {
      return true
    }
  }
  // }
  // 删除访问过的值
  seen.delete(obj)
  return false
}

console.log(hasCircleRefercence({ a: 1 }))
console.logt(hasCircleRefercence(complexObject))
```

### 写一个渲染函数，解析 dom，然后渲染成最终的 dom 元素

- 解析 dom，很明显 dom 结构是一个树状结构，需要递归处理
- 同时不同的 node 节点，需要使用不同的原生 api 创建
- 最后还需要渲染到页面上

```js
// <ul class="list">
//   <li>dingtalk</li>
//   <li>feishu</li>
// </ul>

let vdom = {
  tagName: 'ul',
  props: {
    className: 'list',
  },
  children: [
    {
      tagName: 'li',
      children: 'dingtalk',
    },
    {
      tagName: 'li',
      children: 'feishu',
    },
  ],
}

// 入参：dom结构，容器container
const render = (vDom, container) => {
  // 解构出标签的各个属性
  const { tagName, props, children } = vDom

  // 创建根元素
  const el = document.createElement(tagName)

  // 设置属性
  if (props) {
    Object.keys(props).forEach((k) => {
      // 这里还需要特殊处理，如下
      // className -> class
      el.setAttribute(k, props[k])
    })
  }

  // for in 可以遍历原型上，可枚举的所有属性
  // if (props) {
  //     for (const key in props) {
  //         el.setAttribute(key, props[key])
  //     }
  // }

  // 处理children
  if (Array.isArray(children) && children.length) {
    children.forEach((child) => {
      // 获取子元素，render函数返回当前元素节点，
      // 入参就是当前元素的vdom及父元素
      const childElement = render(child, el)
      el.appendChild(childElement)
    })
  } else if (children) {
    // 文本节点
    const textNode = document.createTextNode(children)
    el.appendChild(textNode)
  }

  container.appendChild(el)

  return el // 返回当前元素，后续作为render的container，递归使用
}

const container = document.getElementsByTagName('body')[0]
render(vdom, container)
```

### 判断有环链表

- 快慢指针，如果相遇就是有环
- 链表是通过 next 属性指向下一个节点的，不是 next()方法
- 快慢指针起点一致，
- 快指针走的快，只需要判断快指针即可
- 先移动再判断，刚开始二者是相同的

```js
const hasCycle = (head) => {
  // const cur = head
  let slow = head
  // const fast = head.next()
  let fast = head // 二者从同一个起点开始即可

  // 因为快指针走的快，只需要判断快指针没问题就可以一直循环
  // while(cur.next()) {
  while (fast && fast.next) {
    // if (slow === fast) {
    //     return true
    // }
    // slow = slow.next()
    // fast = fast.next().next()

    slow = slow.next // 指针是通过next属性指向的，不需要 next() 方法
    fast = fast.next.next
    if (slow === fast) {
      // 另外需要先移动指针，再判断才可以
      return true
    }
  }

  return false
}
```

### 给定单链表的头节点 head ，请反转链表，并返回反转后的链表的头节点。

- 刚开始给的链表的开始结点，需要遍历到结束结点
- 链表可以选用迭代或递归方式完成反转，尝试

```js
// 反转链表
const ListNode = (val, next) => {
  this.val = val === undefined ? 0 : val
  this.next = next === undefined ? null : next
}

const reverseList = (head) => {
  let prev = null
  let cur = head
  // 当前节点有值，则开始移动
  while (cur) {
    // 1->2->3
    // cur.next 就是1指向的下一个，先暂存
    let next = cur.next

    // 然后修改 cur.next 的指向，之前指向2，最后应该是 1<-2<-3
    // 所以，1应该指向null
    cur.next = prev

    // 上面处理完了1，则继续处理2
    prev = cur // 处理2，则pre为1
    cur = next // cur就应该是2
  }
  // 处理完，prev就是头节点，
  // 仔细看while的条件，prev是最后一个有效值，cur会指向null
  return prev
}

const reverseList = (head) => {
  // 递归结束条件
  // 如果链表为空或者只有一个节点，则直接返回该节点，因为反转后的链表就是他自己
  if (head === null || head.next === null) {
    return head
  }

  // 递归是从顶向下，入参是下一个，即head.next
  const nextHead = reverseList(head.next)

  // 如果希望nk+1的下一个节点指向nk，则可以 nk.next.next = nk
  // nk.next 指向下一个也就是nk+1，然后nk.next.next 就是nk+1的指向了
  head.next.next = head
  head.next = null
  // 1->2->3
  // 2.next = 1，2.next本来指向3，现在调整为1
  // 1.next = null，1.next本来指向2，现在调整指向null
  // 调整前两个节点，然后再依次向右循环

  // 这样循环往复，就可以得到最后的头结点
  return nextHead
}
```

### 给定排序升序数组和目标值 target，如果目标值存在则返回下标，如果不存在则返回-1

```js
const search = (nums, target) => {
  const left = 0
  const right = nums.length - 1

  while (left < right) {
    let mid = parseInt((left + right) / 2)

    if (nums[mid] === target) {
      return mid
    } else if (nums[mid] > target) {
      right = mid - 1
    } else {
      left = mid + 1
    }
  }

  // 如果不存在，要求返回最后插入的位置，则一定是 right + 1
  // return right + 1
  return -1
}
```

### x 的 平方根

```js
function squareRoot(x) {
  // 负数没有平方根
  if (x < 0) return NaN
  if ([0, 1].includes(x)) {
    return x
  }

  // 二分法，可以将x想象为长度为x的递增序列，然后找到使 mid * mid = x 的值
  let left = 0
  let right = x
  const precision = 1e-10 // 精度

  while (right - left > precision) {
    // let mid = parseInt((left + right) / 2)
    let mid = (left + right) / 2 // 这里不需要添加取整，因为有精度限制
    // 取整就丢失精度了。

    // 说明，中间值右侧的值都是大值，属于无效值
    if (mid * mid > x) {
      right = mid
    } else {
      left = mid
    }
  }

  // 四舍五入，保证与Math.sqrt
  return Math.round((left + right) / 2)
}
```

### 删除字符串中相邻重复字符串

- 初始化一个空栈
- for of 循环遍历，然后对比栈顶元素与当下正在循环的元素
- 满足条件则删除栈顶元素

```js
const removeDuplicates = (str) => {
  const stacks = []

  for (const char of str) {
    if (stacks.length && stacks[stacks.length - 1] === char) {
      stacks.pop()
    } else {
      stacks.push(char)
    }
  }
  return stacks.join('')
}
console.log(removeDuplicates('abbaca')) // ca
```

### 移除数组中等于某个值的值，复杂度 O(1)，返回最后的长度

- 双指针，右侧指针遍历所有的，左侧指针存储有效值
- 最后返回左指针的大小，就是最终的结果

```js
const removeLement = (nums, val) => {
  let left = 0
  // let right = 0
  const len = nums.length

  for (let right = 0; right < len; right++) {
    // 如果遍历的值，不等于就插入进去
    if (nums[right] !== val) {
      nums[left] = nums[right]
      left++
    }
  }

  return left
}

console.log(removeLement([1, 2, 2, 3, 3, 3], 3)) // 3
```

### LRU 缓存

- map 缓存，有就更新，超过就删最开始的

```js
class MyLRU {
  constructor(size) {
    this.maxSize = size
    this.map = new Map()
  }

  get(key) {
    if (!this.map.has(key)) {
      return -1
    }

    // 如果存在，则删除就得，重新设置
    const val = this.map.get(key)
    this.del(key)
    this.set(key, val)
    return val
  }

  set(key, val) {
    // 如果有，就删除
    if (this.map.has(key)) {
      this.del(key)
    }

    // 如果超过限制，则删除最早的
    if (this.map.size > this.maxSize) {
      // map是个迭代器
      // this.map.keys() 生成一个迭代器，调用next方法，得到对应的值，value就是对应的值，执行一次就是第一个
      this.del(this.map.keys().next().value)
    }

    this.map.set(key, val)
  }

  del(key) {
    this.map.delete(key)
  }
}

const cLru = new MyLRU(2)
cLru.set('a', '111')
cLru.get('a')

// cLru.map.keys().next()
// {value: 'a', done: false}
```

### 给定一个拍平的数组对象结构，生成一个树状结构

1. 结构有 parentId，id，也就是当前元素的 id 和父元素 id
2. 首先遍历，并以 id 为 key，给每个节点添加 children 属性，value 是后续的子节点

```js
const data = [
  { id: 1, parentId: null, label: '1' },
  { id: 2, parentId: 1, label: '2' },
  { id: 3, parentId: 1, label: '3' },
  { id: 4, parentId: 3, label: '4' },
  // ...
]

const convert2Tree = (data) => {
  const tree = []
  const map = {}

  data.forEach((node) => {
    node.children = []
    map[node.id] = node // 用map记录每个节点
  })

  data.forEach((node) => {
    const { parentId, id } = node

    if (parentId === null) {
      // 说明是根节点
      tree.push(node)
    } else {
      // 不是根节点，则需要找父节点
      const parent = map[parentId]
      parent.children.push(node)
    }
  })

  return tree
}

console.log(convert2Tree(data))
```

### 实现串行打印

```js
const sequentialCalls = async (arr) => {
  const runTask = (n) => {
    new Promise((resolve, reject) => {
      setTimeout(() => {
        console.log('djch 几秒：', n * 1000)
        resolve()
      }, n * 1000)
    })
  }

  for (const num of arr) {
    await runTask(num)
  }
}

sequentialCalls([1, 2, 3])
```

### 设计一个异步事件队列

- 这里主要思想是，所有函数内，都会有 cb
- 数组列表里，每一项又都有索引

```js
// 设计一个异步事件队列
class AsyncQueue {
  constructor() {
    // 函数实现
    this.eventMap = {}
  }
  // 事件注册
  tap(name, fn) {
    // 函数实现
    if (this.eventMap[name] !== undefined) {
      this.eventMap[name].push(fn)
    } else {
      this.eventMap[name] = [fn]
    }
  }
  // 事件触发
  exec(name, callback) {
    // 函数实现
    // if (!this.eventMap[name]?.length) return
    // 不要改变现有结构，意味着，不能在exec上使用await
    // 可以在每个回调函数结束后，再处理后续的
    const fns = this.eventMap[name] || []

    // // 如何遍历，同时往下走呢？用reduce？
    // fns.reduce((accumulator, fn, index, array) => {
    //     // 如何得到函数内部逻辑执行完的信号？都有同名的cb函数
    //     fn()
    // })

    // 如果有长度就执行，同时传入下一个函数
    if (fns.length) {
      const next = (idx) => {
        if (idx < fns.length) {
          // 执行当前函数，fns[idx]()
          // 同时将下一个函数传入，作为内部的cb继续调用
          fns[idx](() => next(idx + 1))
        } else {
          // 这里没有了，也需要执行
          callback()
        }
      }
      // 自动执行
      next(0)
    } else {
      callback()
    }
  }
}

function fn1(cb) {
  console.log('fn1')
  cb()
}

function fn2(cb) {
  console.log('fn2')
  cb()
}

function fn3(cb) {
  setTimeout(() => {
    console.log('fn3')
    cb()
  }, 2000)
}

function fn4(cb) {
  setTimeout(() => {
    console.log('fn4')
    cb()
  }, 3000)
}

// 创建事件队列
const asyncQueue = new AsyncQueue()
// 注册事件队列
asyncQueue.tap('init', fn1)
asyncQueue.tap('init', fn2)
asyncQueue.tap('init', fn3)
asyncQueue.tap('init', fn4)
// 执行事件队列
asyncQueue.exec('init', () => {
  console.log('执行结束')
})

// 输出
// fn1
// fn2
// fn3 (延迟2秒输出)
// fn4（延迟3秒输出）
// 执行结束
```

### 实现一个最大并行 max 数量的请求

- 并行发送，超过了就添加新的任务
- 肯定是 Promise，一个主函数，负责添加并返回最终结果
- 一个执行函数，执行具体的逻辑，并重置各个状态

```js
const promiseLimit = (fns, max) => {
  const len = fns.length
  const res = []
  let idx = 0
  let runing = 0 // 正在进行的请求

  return new Promise((resolve, reject) => {
    const runTask = (fn, index) => {
      runing++
      fn()
        .then((v) => {
          runing--
          res[index] = v

          // 每次结束一个函数，都会执行主函数
          walk()
        })
        .catch((err) => {
          res[index] = err
          reject(err)
        })
    }

    // 主函数负责执行，
    const walk = () => {
      // 如果小于并发数，且小于最大长度，说明还有待处理请求
      while (runing < max && idx < len) {
        runTask(fns[idx], idx)
        idx++
      }

      // 如果没有正在执行的了，返回结果
      if (!runing) resolve(res)
    }

    walk()
  })
}

const tasks = [
  () => new Promise((resolve) => setTimeout(() => resolve(1), 1000)),
  () => new Promise((resolve) => setTimeout(() => resolve(2), 2000)),
  () => new Promise((resolve) => setTimeout(() => resolve(3), 3000)),
  () => new Promise((resolve) => setTimeout(() => resolve(4), 4000)),
  () => new Promise((resolve) => setTimeout(() => resolve(5), 5000)),
  () => new Promise((resolve) => setTimeout(() => resolve(6), 6000)),
]

promiseLimit(tasks, 2)
  .then((results) => {
    console.log(results)
  })
  .catch((error) => {
    console.error(error)
  })
```

### 实现 Promise.all、Promise.race 等

```js
// Promise.all(arr) 等到所有逻辑执行完，才返回
// 同时还有顺序，如果成功的话
// 如果失败了，那就整个失败
const myPromiseAll = (fns) => {
  const len = fns.length
  const res = []
  const count = 0

  return new Promise((resolve, reject) => {
    for (let i = 0; i < len; i++) {
      fns[i]
        .then((v) => {
          count++
          res[i] = v

          if (count === len) {
            resolve(res)
          }
        })
        .catch((err) => reject(err))
    }
  })
}

const tasksV1 = [Promise.resolve(1), Promise.resolve(3)]

myPromiseAll(tasksV1).then((res) => console.log('promiseAllV1结果：', res)) // ✅ [1, 3]
```

### 链表中倒数第 k 个节点

- 设置两个指针，一个快指针，先走 k 步，然后再一块走
- 快指针走到头后，慢指针指向的就是倒数第 k 个节点，因为一条绳的总长：k + rest

```js
const kthNode = (head, k) => {
  let fast = head
  let slow = head
  let counter = 0

  while (counter < k) {
    fast = fast.next
    counter++
  }

  while (fast) {
    fast = fast.next
    slow = slow.next
  }

  return slow.val
}
```

### 回文链表

- 方式一：快慢指针，慢指针走到中间，反转后半部分，然后分别对比
- 方式二：遍历到头，然后再遍历两侧的值

```js
const isHuiWen = (head) => {
  // 如果为空或者下一个为空，则直接返回
  if (!head || !head.next) {
    return true
  }

  let fast = head
  let slow = head

  while (fast.next && fast.next.next) {
    fast = fast.next.next
    slow = slow.next
  }

  // 反转后半部分
  let pre = null
  let cur = slow.next

  while (cur) {
    const temp = cur.next
    cur.next = pre
    pre = cur
    cur = temp
  }

  while (head && pre) {
    if (head.val !== pre.val) {
      return false
    }
    head = head.next
    pre = pre.next
  }

  return true
}

const isPalindrome = (head) => {
  let res = ''

  while (head) {
    res += head.val
    head = head.next
  }

  for (let i = 0, j = res.length - 1; i < j; i++, j--) {
    if (res[i] !== res[j]) {
      return false
    }
  }
  return true
}
```

### 判断回文字符串

从中间分开，然后从两侧挨个判断是否一致

```js
function isPalindrome(str) {
  let left = 0
  let right = str.length - 1
  let i = 0
  // 注意，这里只能遍历到 1/2的长度
  // for (i; i < str.length-1; i++) {
  for (i; i < str.length / 2; i++) {
    if (str[left] === str[right]) {
      left++
      right--
    } else {
      return false
    }
  }
  return true
}

function isPalindrome(str) {
  var len = str.length
  for (var i = 0; i < len / 2; i++) {
    if (str[i] !== str[len - 1 - i]) {
      return false
    }
  }
  return true
}
console.log(isPalindrome('racecar')) // true
console.log(isPalindrome('hello')) // false
```

### 重复的字符串

给定一个非空的字符串 s ，检查是否可以通过由它的一个子串重复多次构成。

```
输入: s = "abab"
输出: true
```

```js
var repeatedSubstringPattern1 = function (s) {
  // \1+ 表示匹配一个或多个与第一个捕获组相同的字符。其中 \1 表示第一个捕获组的内容，+ 表示至少匹配一个。
  let reg = /^(\w+)\1+$/
  return reg.test(s)
}

var repeatedSubstringPattern2 = function (s) {
  // abab abab => 'bababa'
  // 拼接两个，然后前后各去掉一个。
  let s1 = (s + s).slice(1, -1)
  // bababa  abab
  return s1.indexOf(s) !== -1
}
```

### 相交链表

提示词：想象两条交汇的路 A 和 B，最后变成一条路，但 A 和 B 从哪里来是未知的

1. 因为 A 和 B 的长度不一，所以二者需要先走 Math.abs(A - B) 长度
2. 然后再挨个判断是否一致
3. 给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回 null 。

```js
const getIntersectionNode = (head1, head2) => {
  let len1 = 0
  let len2 = 0
  let cur1 = head1
  let cur2 = head2

  while (cur1 && cur1.next) {
    cur1 = cur1.next
    len1++
  }

  while (cur2 && cur2.next) {
    cur2 = cur2.next
    len2++
  }

  cur1 = head1
  cur2 = head2

  if (len1 > len2) {
    for (let i = 0; i < len1 - len2; i++) {
      cur1 = cur1.next
    }
  } else {
    for (let i = 0; i < len2 - len2; i++) {
      cur2 = cur2.next
    }
  }

  // 挨个对比
  while (cur1 !== cur2) {
    cur1 = cur1.next
    cur2 = cur2.next
  }

  return cur1
}
```

### 深度优先和广度优先

#### 二叉树遍历方法

#### 二叉树最大，最小深度

### 判断字符串中的有效括号

- 定义一个括号的映射 map
- 遍历字符串，如果没有存储，则加入 stacks，有则弹出最后一个对比。

```js
const isValid = (str) => {
  let stack = []
  let map = {
    ')': '(',
    '}': '{',
    ']': '[',
  }

  for (let ch of str) {
    if (!map[ch]) {
      // 说明是左括号，可以继续压入
      stack.push(ch)
    } else {
      // 有括号，则需要弹出最后一个与之对比
      if (stack.pop() !== map[ch]) {
        return false
      }
    }
  }

  return !stack.length
}
```

### 大数相加

- 大数一般都是用字符串表示
- 相加最后有一个 res
- 相加还有进位，

```js
const bigNumAdd = (a, b) => {
  // 大数一般都是用字符串表示
  let i = a.length - 1
  let j = b.length - 1

  let res = ''
  let carry = 0 // 进位

  // 只要有数字没有循环完，就遍历
  while (i >= 0 || j >= 0) {
    let x = 0
    let y = 0
    let sum = 0

    // 分别取出两个数
    if (i >= 0) {
      x = +a[i]
      i--
    }

    if (j >= 0) {
      y = +b[j]
      j--
    }

    sum = x + y + carry

    if (sum >= 10) {
      carry = 1
      sum -= 10
    } else {
      carry = 0
    }

    // 新累加的数字，在左侧
    res = sum + res
  }

  if (carry) {
    res = carry + res
  }

  return res
}

console.log(bigNumAdd('11111111111111111111', '2222222222'))
```

### 滑动窗口算法，实现无重复字符的最长子串

给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。

```
输入: s = "abcabcbb"
输出: 3
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```

- 利用双指针，模拟一个窗口，有点类似去除数组中与某个值相同的项

```js
const lengthOfLongestSubstring = (str) => {
  // let left = 0 // 虽然是双指针，但用不到
  let right = 0
  let res = ''
  let maxLen = 0

  while (right < str.length) {
    // 如果right所在的字符串，不在res里，则继续向右
    if (res.indexOf(str[right]) === -1) {
      res += str[right]
      right++

      maxLen = Math.max(res.length, maxLen)
    } else {
      // 此时与最左边重复了，需要右移字符串
      res = res.slice(1, right + 1)
    }
  }
  return maxLen
}

console.log(lengthOfLongestSubstring('abcabcbb')) // 3
```

### 盛最多水的容器

给定一个长度为 n 的整数数组 height，有 n 条垂线，第 i 条线的两个端点是 `(i, 0) 和 (i, height[i])`

找出其中的两条线，使得他们与 x 轴共同组成的容器可以容纳最多的水。

返回容器可以存储的最大水量

```
输入：[1,8,6,2,5,4,8,3,7]
输出：49
解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。
```

- 利用双指针
- 区域面积是长 \* 宽，
- 移动两侧指针，移动小的

```js
const maxArea = (arr) => {
  let len = arr.length
  let leftIdx = 0
  let rightIdx = len - 1
  let max = 0

  while (leftIdx < rightIdx) {
    let tempArea = (rightIdx - leftIdx) * Math.min(arr[leftIdx], arr[rightIdx])

    // 更新最大值
    max = Math.max(max, tempArea)

    // 移动小的，才可能出现大值
    arr[leftIdx] < arr[rightIdx] ? leftIdx++ : rightIdx--
  }

  return max
}
console.log(maxArea([1, 8, 6, 2, 5, 4, 8, 3, 7])) // 49
```

### 接雨水

题目：给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。【力扣 42 题】

```
输入：height = [4,2,0,3,2,5]
输出：9
```

- 可以理解为，一排高低不同的实心阶梯，下雨后，阶梯里可以存多少水
- 只有低的柱子，也就是形成坑，才可能存水。。。木桶效应
- 双指针，从两侧往里遍历，然后判断双指针指向的柱子，谁高谁低，
- 需记录每次的最高高度
- 该算法的时间复杂度为 O(n)，空间复杂度为 O(1)。

```js
const trap = (heights) => {
  let left = 0
  let right = heights.length - 1
  let maxLeft = 0
  let maxRight = 0
  let res = 0

  while (left < right) {
    if (heights[left] < heights[right]) {
      // 左侧低，统计左侧的水量
      if (heights[left] > maxLeft) {
        maxLeft = heights[left]
      } else {
        // 比最大值小，说明形成了洼地
        res += maxLeft - heights[left]
      }
      // 指针移动
      left++
    } else {
      if (heights[right] > maxRight) {
        maxRight = heights[right]
      } else {
        res += maxRight - heights[right]
      }
      right--
    }
  }

  return res
}

console.log(trap([4, 2, 0, 3, 2, 5]))
```

### 输出 50 以内斐波那契数列

```js
const fib = (num) => {
  if (num === 1 || num === 2) {
    return 1
  }

  return fib(num - 1) + fib(num - 2)
}
```

上面的算法很耗时

```js
const fibPro = (num) => {
  if (num < 2) {
    return [0, 1]
  }

  // 最后的结果肯定是：target = fibPro(num - 1) + fibPro(num) 也就是倒数第二位 + 倒数第一位
  // target = fibPro(num - 1) + (fibPro(num - 1) + fibPro(num - 2))

  // 定义数组，且初始化的值为 倒数第二位
  let arr = fibPro(num - 1)

  // 加入最后一位的值，是前两者的和
  arr.push(arr[arr.length - 1] + arr[arr.length - 2])
  return arr
}

fibPro(10) // [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]

const fib2 = (num) => {
  let arr = [0, 1]
  if (num < 2) {
    return arr.slice(0, num)
  }

  for (let i = 2; i < num; i++) {
    arr.push(arr[i - 1], arr[i - 2])
  }

  return arr
}

fib2(5) // [0, 1, 1, 2, 3]
fib2(10) // [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]

// 前n项斐波那契梳理的和。
const fibSum = (n) => {
  let sum = 0
  let a = 0
  let b = 1

  for (let i = 0; i < n; i++) {
    sum += b

    // 模拟斐波那契数列
    let temp = a + b
    a = b
    b = temp
  }

  return sum
}
console.log(fibSum(10)) // 输出：143
```
