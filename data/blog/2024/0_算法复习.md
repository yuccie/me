---
title: '算法复习'
date: Mon Dec 23 2024 21:09:19 GMT+0800 (中国标准时间)
lastmod: '2024-12-23'
tags: ['数据结构', '算法']
draft: false
summary: '算法与数据结构'
layout: PostSimple
bibliography: references-data.bib
canonicalUrl: https://dume.vercel.app/blog/2024/0_算法复习.md
---

## 算法

### 深拷贝

```js
const complexObject = {
  number: 42,
  string: 'Hello, World!',
  boolean: true,
  nullValue: null,
  undefinedValue: undefined,
  symbol: Symbol('mySymbol'),
  array: [1, 2, 3, 'a', 'b', 'c'],
  object: {
    nestedNumber: 100,
    nestedString: 'nested string',
  },
  functionValue: function () {
    console.log('This is a function')
  },
  regexp: /test/gi,
  date: new Date(),
  error: new Error('This is an error'),
  map: new Map([
    ['key1', 'value1'],
    ['key2', 'value2'],
  ]),
  set: new Set([5, 10, 15, 20]),
  weakMap: new WeakMap([
    [{ key: 'weakKey1' }, 'value1'],
    [{ key: 'weakKey2' }, 'value2'],
  ]),
  weakSet: new WeakSet([{ key: 'weakSetKey1' }, { key: 'weakSetKey2' }]),

  // 循环引用
  selfReference: null,
}

// 设置循环引用
complexObject.selfReference = complexObject

const deepClone = (target) => {
  const isWhat = (v) => Object.prototype.toString.call(v).slice(8, -1)
  const cWeakMap = new WeakMap()

  const _deep = (data) => {
    if (isWhat(data) === 'Date') return new Date(data)

    if (!['Array', 'Object'].includes(isWhat(data))) return data

    if (cWeakMap.has(data)) return cWeakMap.get(data)

    const res = Array.isArray(data) ? [] : {}

    cWeakMap.set(data, res)

    Object.keys(data).forEach((k, v) => {
      if (res[k]) return
      res[k] = _deep(data[k])
    })

    return res
  }

  return _deep(target)
}

console.log(deepClone(complexObject))
```

### x 的 n 次方

- 很容易想到，一个数的正 n 次方，遍历相乘即可
- 但丢失了 0、负数的场景
- 同时算法的复杂度是，O(n)

```js
const xFn = (x, n) => {
  let res = 1 // 初始值是1
  while (n-- > 0) {
    res = res * x
  }
  return res
}
console.log(xFn(2, 3)) // 8
```

修复上面的问题

```js
const xFnPro = (x, n) => {
  // 如果是0、负数、整数
  if (n === 0) return 1
  // 如果是负数，则取倒数
  if (n < 0) {
    return 1 / xFnPro(x, -n)
  }

  if (n % 2) {
    return x * xFnPro(x, n - 1)
  }

  // 当是偶数时，比如 2^4，常规需要乘四次，变个思路就需要乘两次了
  // 如 xFnPro(2 * 2, 4 / 2) 只需要乘两次，从而降低运算次数，也就是降低了复杂度
  // 最终复杂度是 O(logn) 相比O(n) 确实小不少
  return xFnPro(x * x, n / 2)
}

console.log(xFnPro(2, -2)) // 0.25
console.log(xFnPro(2, 0)) // 1
console.log(xFnPro(2, 2)) // 4
```

### 判断循环引用

只需要用一个对象，记录访问过的对象即可，类似深拷贝中的 weakMap，但需要注意 weakMap 的入参以及退出条件

```js
const hasCircleRefercence = (obj, seen = new WeakMap()) => {
  // 简单数据类型，不可能发生引用
  // 数据类型是大写，因为weakMap的key是对象，因此还不能简单的判断 ['Null', 'Undefined', 'String']
  // if (['Null', 'Undefined', 'String'].includes(isWhat(obj))) return false
  if (!['Object', 'Array'].includes(isWhat(obj))) return false

  if (seen.has(obj)) return true

  // 将这个对象设置为访问过的状态
  seen.set(obj, true)

  // 遍历对象内部的各个值
  // 还需要针对数组和对象进行遍历
  // if (['Array', 'Object'].includes(isWhat(obj))) {
  for (const key of Object.keys(obj)) {
    // 这里不要忘记传入 seen
    if (hasCircleRefercence(obj[key], seen)) {
      return true
    }
  }
  // }
  // 删除访问过的值
  seen.delete(obj)
  return false
}

console.log(hasCircleRefercence({ a: 1 }))
console.logt(hasCircleRefercence(complexObject))
```

### 写一个渲染函数，解析 dom，然后渲染成最终的 dom 元素

- 解析 dom，很明显 dom 结构是一个树状结构，需要递归处理
- 同时不同的 node 节点，需要使用不同的原生 api 创建
- 最后还需要渲染到页面上

```js
// <ul class="list">
//   <li>dingtalk</li>
//   <li>feishu</li>
// </ul>

let vdom = {
  tagName: 'ul',
  props: {
    className: 'list',
  },
  children: [
    {
      tagName: 'li',
      children: 'dingtalk',
    },
    {
      tagName: 'li',
      children: 'feishu',
    },
  ],
}

// 入参：dom结构，容器container
const render = (vDom, container) => {
  // 解构出标签的各个属性
  const { tagName, props, children } = vDom

  // 创建根元素
  const el = document.createElement(tagName)

  // 设置属性
  if (props) {
    Object.keys(props).forEach((k) => {
      // 这里还需要特殊处理，如下
      // className -> class
      el.setAttribute(k, props[k])
    })
  }

  // for in 可以遍历原型上，可枚举的所有属性
  // if (props) {
  //     for (const key in props) {
  //         el.setAttribute(key, props[key])
  //     }
  // }

  // 处理children
  if (Array.isArray(children) && children.length) {
    children.forEach((child) => {
      // 获取子元素，render函数返回当前元素节点，
      // 入参就是当前元素的vdom及父元素
      const childElement = render(child, el)
      el.appendChild(childElement)
    })
  } else if (children) {
    // 文本节点
    const textNode = document.createTextNode(children)
    el.appendChild(textNode)
  }

  container.appendChild(el)

  return el // 返回当前元素，后续作为render的container，递归使用
}

const container = document.getElementsByTagName('body')[0]
render(vdom, container)
```

### 判断有环链表

- 快慢指针，如果相遇就是有环
- 链表是通过 next 属性指向下一个节点的，不是 next()方法
- 快慢指针起点一致，
- 快指针走的快，只需要判断快指针即可
- 先移动再判断，刚开始二者是相同的

```js
const hasCycle = (head) => {
  // const cur = head
  let slow = head
  // const fast = head.next()
  let fast = head // 二者从同一个起点开始即可

  // 因为快指针走的快，只需要判断快指针没问题就可以一直循环
  // while(cur.next()) {
  while (fast && fast.next) {
    // if (slow === fast) {
    //     return true
    // }
    // slow = slow.next()
    // fast = fast.next().next()

    slow = slow.next // 指针是通过next属性指向的，不需要 next() 方法
    fast = fast.next.next
    if (slow === fast) {
      // 另外需要先移动指针，再判断才可以
      return true
    }
  }

  return false
}
```

### 给定单链表的头节点 head ，请反转链表，并返回反转后的链表的头节点。

- 刚开始给的链表的开始结点，需要遍历到结束结点
- 链表可以选用迭代或递归方式完成反转，尝试

```js
// 反转链表
const ListNode = (val, next) => {
  this.val = val === undefined ? 0 : val
  this.next = next === undefined ? null : next
}

const reverseList = (head) => {
  let prev = null
  let cur = head
  // 当前节点有值，则开始移动
  while (cur) {
    // 1->2->3
    // cur.next 就是1指向的下一个，先暂存
    let next = cur.next

    // 然后修改 cur.next 的指向，之前指向2，最后应该是 1<-2<-3
    // 所以，1应该指向null
    cur.next = prev

    // 上面处理完了1，则继续处理2
    prev = cur // 处理2，则pre为1
    cur = next // cur就应该是2
  }
  // 处理完，prev就是头节点，
  // 仔细看while的条件，prev是最后一个有效值，cur会指向null
  return prev
}

const reverseList = (head) => {
  // 递归结束条件
  // 如果链表为空或者只有一个节点，则直接返回该节点，因为反转后的链表就是他自己
  if (head === null || head.next === null) {
    return head
  }

  // 递归是从顶向下，入参是下一个，即head.next
  const nextHead = reverseList(head.next)

  // 如果希望nk+1的下一个节点指向nk，则可以 nk.next.next = nk
  // nk.next 指向下一个也就是nk+1，然后nk.next.next 就是nk+1的指向了
  head.next.next = head
  head.next = null
  // 1->2->3
  // 2.next = 1，2.next本来指向3，现在调整为1
  // 1.next = null，1.next本来指向2，现在调整指向null

  // 这样循环往复，就可以得到最后的头结点
  return nextHead
}
```

### 给定排序升序数组和目标值 target，如果目标值存在则返回下标，如果不存在则返回-1

```js
const search = (nums, target) => {
  const left = 0
  const right = nums.length - 1

  while (left < right) {
    let mid = parseInt((left + right) / 2)

    if (nums[mid] === target) {
      return mid
    } else if (nums[mid] > target) {
      right = mid - 1
    } else {
      left = mid + 1
    }
  }

  // 如果不存在，要求返回最后插入的位置，则一定是 right + 1
  // return right + 1
  return -1
}
```

### x 的 平方根

```js
function squareRoot(x) {
  // 负数没有平方根
  if (x < 0) return NaN
  if ([0, 1].includes(x)) {
    return x
  }

  // 二分法，可以将x想象为长度为x的递增序列，然后找到使 mid * mid = x 的值
  let left = 0
  let right = x
  const precision = 1e-10 // 精度

  while (right - left > precision) {
    // let mid = parseInt((left + right) / 2)
    let mid = (left + right) / 2 // 这里不需要添加取整，因为有精度限制
    // 取整就丢失精度了。

    // 说明，中间值右侧的值都是大值，属于无效值
    if (mid * mid > x) {
      right = mid
    } else {
      left = mid
    }
  }

  // 四舍五入，保证与Math.sqrt
  return Math.round((left + right) / 2)
}
```

### 删除字符串中相邻重复字符串

- 初始化一个空栈
- for of 循环遍历，然后对比栈顶元素与当下正在循环的元素
- 满足条件则删除栈顶元素

```js
const removeDuplicates = (str) => {
  const stacks = []

  for (const char of str) {
    if (stacks.length && stacks[stacks.length - 1] === char) {
      stacks.pop()
    } else {
      stacks.push(char)
    }
  }
  return stacks.join('')
}
console.log(removeDuplicates('abbaca')) // ca
```

### 移除数组中等于某个值的值，复杂度 O(1)，返回最后的长度

- 双指针，右侧指针遍历所有的，左侧指针存储有效值
- 最后返回左指针的大小，就是最终的结果

```js
const removeLement = (nums, val) => {
  let left = 0
  // let right = 0
  const len = nums.length

  for (let right = 0; right < len; right++) {
    // 如果遍历的值，不等于就插入进去
    if (nums[right] !== val) {
      nums[left] = nums[right]
      left++
    }
  }

  return left
}

console.log(removeLement([1, 2, 2, 3, 3, 3], 3)) // 3
```

### LRU 缓存

- map 缓存，有就更新，超过就删最开始的

```js
class MyLRU {
  constructor(size) {
    this.maxSize = size
    this.map = new Map()
  }

  get(key) {
    if (!this.map.has(key)) {
      return -1
    }

    // 如果存在，则删除就得，重新设置
    const val = this.map.get(key)
    this.del(key)
    this.set(key, val)
    return val
  }

  set(key, val) {
    // 如果有，就删除
    if (this.map.has(key)) {
      this.del(key)
    }

    // 如果超过限制，则删除最早的
    if (this.map.size > this.maxSize) {
      // map是个迭代器
      // this.map.keys() 生成一个迭代器，调用next方法，得到对应的值，value就是对应的值，执行一次就是第一个
      this.del(this.map.keys().next().value)
    }

    this.map.set(key, val)
  }

  del(key) {
    this.map.delete(key)
  }
}

const cLru = new MyLRU(2)
cLru.set('a', '111')
cLru.get('a')

// cLru.map.keys().next()
// {value: 'a', done: false}
```

### 给定一个拍平的数组对象结构，生成一个树状结构

1. 结构有 parentId，id，也就是当前元素的 id 和父元素 id
2. 首先遍历，并以 id 为 key，给每个节点添加 children 属性，value 是后续的子节点

```js
const data = [
  { id: 1, parentId: null, label: '1' },
  { id: 2, parentId: 1, label: '2' },
  { id: 3, parentId: 1, label: '3' },
  { id: 4, parentId: 3, label: '4' },
  // ...
]

const convert2Tree = (data) => {
  const tree = []
  const map = {}

  data.forEach((node) => {
    node.children = []
    map[node.id] = node // 用map记录每个节点
  })

  data.forEach((node) => {
    const { parentId, id } = node

    if (parentId === null) {
      // 说明是根节点
      tree.push(node)
    } else {
      // 不是根节点，则需要找父节点
      const parent = map[parentId]
      parent.children.push(node)
    }
  })

  return tree
}

console.log(convert2Tree(data))
```
