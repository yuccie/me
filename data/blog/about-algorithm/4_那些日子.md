---
title: 那些日子
date: Sun Nov 19 2023 16:06:28 GMT+0800 (中国标准时间)
lastmod: 2023/11/19
tags: [day, 巩固]
draft: false
summary: 要想看起来毫不费力,就需要背后用尽全力
layout: PostSimple
bibliography: references-data.bib
canonicalUrl: https://dume.vercel.app/blog/about-algorithm/4_那些日子.md
---

## 20231119 周日

### 字符串

### 常规算法

#### 继承

##### 1、 原型链继承

父类的实例，作为子类的原型对象

```js
function Parent() {
  this.name = 'parent'
}
Parent.prototype.sayHi = function () {
  console.log('hi')
}

function Child() {
  this.name = 'child'
  this.age = 12
}

Child.prototype = new Parent()

var child = new Child()

console.log(child.name, child.age) // parent 12
child.sayHi() // hi

child.name = 'child'
console.log(child.name) // child
console.log(new Parent().name) // child

// 包含引用类型值的原型属性会被所有实例共享
function SuperType() {
  this.colors = ['red', 'blue', 'green']
}

function SubType() {}

//inherit from SuperType
SubType.prototype = new SuperType()

var instance1 = new SubType()

instance1.colors.push('black')
console.log(instance1.colors) //"red,blue,green,black"

var instance2 = new SubType()
console.log(instance2.colors) //"red,blue,green,black"
```

特点：

- 父类引用类型，会被子类实例继承，容易造成修改的相互影响
- 没办法传参数

##### 2、 借用构造函数继承

```js
function Parent() {
  this.arr = [1, 2, 3]
}
function Child() {
  Parent.call(this)
}

var child1 = new Child()
child1.arr.push('4')
console.log(child1.arr) // [1,2,3,4]

var child2 = new Child()
console.log(child2.arr) // [1,2,3]
```

上面的代码，引用类型，不会再在所有实例间共享了

那参数呢？

```js
function Parent(name = 'parent default') {
  this.name = name
}
function Child(name) {
  Parent.call(this, name)
  this.age = 18
}

var child1 = new Child()
console.log(child1.name) // parent default

var child2 = new Child('son')
console.log(child2.name) // son
```

##### 3、组合继承

将**原型链继承和借用构造函数继承**，组合到一块

```js
function Parent(name) {
  this.name = name
  this.arr = [1, 2, 3]
}
Parent.prototype.sayName = function () {
  console.log(this.name)
}

function Child(name, age) {
  Parent.call(this, name)
  this.age = age
}
Child.prototype = new Parent()
Child.prototype.sayAge = function () {
  console.log(this.age)
}

var c1 = new Child('c1', 20)
c1.arr.push(4)

console.log(c1.arr) // [1,2,3,4]
c1.sayAge() // 20
c1.sayName() // c1

var c2 = new Child('c2', 22)

console.log(c2.arr) // [1,2,3,4]
c2.sayAge() // 22
c2.sayName() // c2
```

##### 4、原型式继承

通过创建一个临时的中间对象， 将该对象作为新创建对象的原型，实现继承

- 定义一个空函数 F，设置 F.prototype = obj，然后返回 new F()

```js
function createObj(obj) {
  function F() {}
  // 和原型链式相比，这里直接使用的obj，而不是 新实例
  F.prototype = obj
  return new F()
}
var person = {
  name: 'p1',
  friends: [1, 2, 3],
}
var p1 = createObj(person)
console.log(p1.name) // p1
p1.friends.push(4)
console.log(p1.friends) // [1,2,3,4]

var p2 = createObj(person)
console.log(p2.name) // p1
console.log(p2.friends) // [1,2,3,4]
```

##### 5、寄生式继承

其实就是使用 Object.create 创建一个对象，然后再操作对象，可以理解为寄生在 Object.create 里

```js
function createObj(proto) {
  var obj = Object.create(proto)
  // 为对象添加函数，会由于不能做到函数复用而降低效率
  obj.greet = function () {
    console.log('hello')
  }
  return obj
}
var parent = {
  name: 'Parent',
  sayHello: function () {
    console.log('Hello')
  },
}

var child = createObj(parent)
console.log(child.name) // 输出：'Parent'
```

##### 6、组合式继承

组合式是：借用构造函数式 + 寄生式

```js
function Parent(name) {
  this.name = name
}

Parent.prototype.sayHello = function () {
  console.log('Hello, I am ' + this.name)
}

function Child(name, age) {
  Parent.call(this, name)
  this.age = age
}

Child.prototype = Object.create(Parent.prototype)
Child.prototype.constructor = Child

Child.prototype.sayAge = function () {
  console.log('I am ' + this.age + ' years old')
}

var child = new Child('Alice', 10)
console.log(child.name) // 输出：'Alice'
child.sayHello() // 输出：'Hello, I am Alice'
child.sayAge() // 输出：'I am 10 years old'
```

##### 7、寄生组合式继承

- 其实就是 借用构造函数 + 原型式 + 寄生式

```js
function object(o) {
  function F() {}
  F.prototype = o
  return new F()
}

function inheritPrototype(subType, superType) {
  var prototype = object(superType.prototype) // 创建对象
  prototype.constructor = subType // 增强对象
  subType.prototype = prototype // 指定对象
}

function SuperType(name) {
  this.name = name
  this.colors = ['red', 'blue', 'green']
}

SuperType.prototype.sayName = function () {
  alert(this.name)
}

function SubType(name, age) {
  SuperType.call(this, name)

  this.age = age
}

inheritPrototype(SubType, SuperType)

SubType.prototype.sayAge = function () {
  alert(this.age)
}

var instance1 = new SubType('Nicholas', 29)
instance1.colors.push('black')
alert(instance1.colors) //"red,blue,green,black"
instance1.sayName() //"Nicholas";
instance1.sayAge() //29

var instance2 = new SubType('Greg', 27)
alert(instance2.colors) //"red,blue,green"
instance2.sayName() //"Greg";
instance2.sayAge() //27
```

#### bind、call、apply 实现

手动实现 apply，我们要知道 apply ，就是修改 this 指向，然后立即执行函数罢了

- 而如何修改 this 指向呢？ 对象调用就 ok，
- 注意在使用 this 时，箭头函数务必要注意

```js
// 实现apply
Function.prototype.myApply = function (ctx, args) {
  ctx = ctx || window

  const uuid = Symbol()
  ctx[uuid] = this // 这里把this，也就是后续的函数，挂载在一个属性上，类似 ctx.fn = this
  // const args = [...arguments].slice(1)[0] // apply的参数二是个数组，也可以手动截取

  // 调用 // 注意：这里函数的入参 ...args 这样写，目的是为了拉齐，原生的apply，虽然不知道原生底层如何实现
  const res = ctx[uuid](...args)
  // 删除多余属性
  delete ctx[uuid]

  // 返回结果
  return res
}

// 注意：这里函数的入参 ...arr 这样写，目的是为了拉齐，原生的apply，虽然不知道原生底层如何实现
function greet(...arr) {
  // ...arr 相当于将多个参数，放在数组arr里
  // console.log(arr) // 打印数组
  console.log('hello', this.name, arr.join(' '))
}

var obj = { name: 'test' }

console.log(greet.apply(obj, ['hi apply', 'hello'])) // hello test hi apply hello
console.log(greet.myApply(obj, ['hi myapply', 'hello'])) // hello test hi myapply hello

// 实现 call
Function.prototype.myCall = function (ctx) {
  ctx = ctx || window

  // 第一项是 ctx，第二项才是 call 的入参
  const args = [...arguments].slice(1)

  const uuid = Symbol() // 防止重复
  ctx[uuid] = this // 指向未来的函数

  const res = ctx[uuid](...args)
  delete ctx[uuid]
  return res
}

var obj = { name: 'obj' }
function greet(args) {
  console.log('hello', this.name, args.join(' '))
}

greet.myCall(obj, ['hello', 'mycall']) // hello obj hello mycall
greet.call(obj, ['hello', 'call']) // hello obj hello call

// 实现bind
Function.prototype.mybind = function (ctx) {
  ctx = ctx || window

  const uuid = Symbol()
  ctx[uuid] = this

  const args = [...arguments].slice(1)

  return function (...args1) {
    const res = ctx[uuid](...args1, ...args)
    delete ctx[uuid]
    return res
  }
}

var obj = { name: 'bind' }

function greet(...args) {
  console.log('hi', this.name, args.join(' '))
}

var myGreet = greet.bind(obj, 'outer', 'haha')
myGreet()

var myGreet1 = greet.mybind(obj, 'outer', 'haha')
myGreet1()
```

#### 深拷贝

- 思路，其实就是遍历对象，然后递归拷贝
- 需要处理特殊数据类型

```js
const originalObj1 = {
  name: 'John',
  age: 30,
  address: {
    city: 'New York',
    country: 'USA',
  },
  nu: null,
  undf: undefined,
  reg: /\d/g,
  arr: [1, 2],
  fn: () => console.log('fn'),
  date: new Date(),
  symbol: Symbol(), // 不是构造函数，不能用 new
}

const deepClone = (target) => {
  const wMap = new WeakMap()

  const isType = (v) => Object.prototype.toString.call(v).slice(8, -1)
  // 需要递归
  const _deep = (obj) => {
    // 时间类型
    if (isType(obj) === 'Date') {
      return new Date(obj)
    }
    // 如果不是数组或者对象，直接返回
    if (!['Array', 'Object'].includes(isType(obj))) {
      return obj
    }

    // 如果是对象，则开始处理对象
    const res = Array.isArray(obj) ? [] : Object.create(null)

    // 已对象本身作为key，然后res作为val，防止循环引用
    if (wMap.has(obj)) {
      return wMap.get(obj)
    }
    wMap.set(obj, res) // 否则就存入map

    // 遍历对象，递归拷贝
    Object.keys(obj).forEach((key) => {
      if (res[key]) return // 如果已经复制，直接返回
      res[key] = _deep(obj[key]) // 递归拷贝
    })

    // 最后返回
    return res
  }

  return _deep(target)
}

const originalObj2 = deepClone(originalObj1)

console.log(originalObj2.address === originalObj1.address) // false
```

#### 节流

思路：

- 如果立即执行的话，不需要像防抖那样用 flag
- 如果没有剩余时间，则立即执行，同时清空 timer
- 如果有剩余时间，且没有定时器，则新建定时器

```js
const throttle = (fn, duration = 300) => {
  let timer = null
  let lastTime = 0

  return function (...args) {
    let currentTime = Date.now()
    let restTime = duration - (currentTime - lastTime)

    // 如果没有剩余时间，则立即执行，同时清除定时器
    if (restTime <= 0) {
      clearTimeout(timer) // 可以防止定时器泄露
      timer = null
      fn.apply(this, args)
      lastTime = currentTime // lastTime是上次执行的时间，因此这里这样赋值
    } else if (!timer) {
      timer = setTimeout(() => {
        fn.apply(this, args)
        timer = null
        lastTime = Date.now()
      }, restTime)
    }
  }
}

window.addEventListener(
  'resize',
  throttleImmediate(() => {
    console.log('节流')
  }, 1000)
)
```

#### 防抖

思路：

1. 返回函数
2. 再次触发，清空定时器，并延迟

```js
// 简单的
function debounce(fn, interval = 300) {
  let timer = null
  return () => {
    clearTimeout(timer)
    timer = setTimeout(fn, interval)
  }
}
const fun = () => console.log(1111)
window.addEventListener(
  'resize',
  debounce(() => console.log(1111), 1000)
)
window.addEventListener('resize', debounce(fun, 1000))
```

上面的只是普通的防抖，还可以立即执行

```js
// 带立即执行的
function debounceImmediate(fn, interval = 300, immediate = true) {
  let timer = null
  return () => {
    clearTimeout(timer)
    if (immediate) {
      // 如果立即执行，则清除定时器，并执行
      immediate = false
      fn.apply(null)
    } else {
      timer = setTimeout(() => {
        fn.apply(null)
        immediate = true
      }, interval)
    }
  }
}

const fun2 = () => console.log(2222)
window.addEventListener('resize', debounceImmediate(fun2, 1000))
```
