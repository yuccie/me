---
title: 那些日子
date: Sun Nov 19 2023 16:06:28 GMT+0800 (中国标准时间)
lastmod: 2023/11/19
tags: [day, 巩固]
draft: false
summary: 要想看起来毫不费力,就需要背后用尽全力
layout: PostSimple
bibliography: references-data.bib
canonicalUrl: https://dume.vercel.app/blog/about-algorithm/4_那些日子.md
---

## 20231201 周五

### vue3 与 vue2 的区别

#### diff 算法区别

Vue 3.x 与 Vue 2.x 在 diff 算法上有很大的不同。Vue 3.0 采用了基于 Proxy 的响应式系统，重写了虚拟 DOM 的内部实现，相对于 Vue 2.x 的 diff 算法，有以下不同之处：

- Vue 2 使用的是基于递归的双指针的 diff 算法，而 Vue 3 使用的是基于数组的动态规划的 diff 算法。Vue 3 的算法效率更高，因为它使用了一些优化技巧，例如按需更新、静态标记等。
- Vue 2 的 diff 算法会对整个组件树进行完整的遍历和比较，而 Vue 3 的 diff 算法会跳过静态子树的比较，只对动态节点进行更新。这减少了不必要的比较操作，提高了性能。
- Vue 2 的 diff 算法对于列表渲染（v-for）时的元素重新排序会比较低效，需要通过给每个元素设置唯一的 key 来提高性能。而 Vue 3 的 diff 算法在列表渲染时，通过跟踪元素的移动，可以更好地处理元素的重新排序，无需设置 key。
- Vue 3 的 diff 算法对于静态节点的处理更加高效，静态节点只会在首次渲染时被处理，后续更新时会直接跳过比较和更新操作，减少了不必要的计算。

1. 静态提升和组合：Vue 2.x 中静态节点会在更新时重复比较，但在 Vue 3.0 中，静态节点会被静态提升并缓存，大幅减少了比较时间。另外，Vue 3.0 借鉴了 React 的 fragments 技术，可以通过 createBlock() 函数将多个子元素组成一组返回，避免了不必要的包装和渲染。
2. 源码卷积：Vue 3.0 是使用模块化源代码，尤其是在虚拟 DOM 中，将所有功能都分装为 create 函数，优化了组件的运行时速度。
   支持 HOC：对于复杂组件，Vue 3.0 可以通过 defineComponent 和 withDirectives 等方法支持 HOC 装饰器和指令功能，让组件变得更加灵活、可复用性更高。
3. 支持 HOC：对于复杂组件，Vue 3.0 可以通过 defineComponent 和 withDirectives 等方法支持 HOC 装饰器和指令功能，让组件变得更加灵活、可复用性更高。
4. vue 3.x 在更新时采用了双缓存技术并优化了虚拟 DOM 的实现原理，相较于 Vue 2.x 的 diff 算法，更新的效率和性能都有很大的提高。

在 Vue 3 的 diff 算法中，它通过跟踪元素的移动来确定元素的重新排序，而不依赖于设置 key。当列表发生重排时，Vue 3 会根据元素的身份（identity）来判断元素的移动方式，从而避免了不必要的元素销毁和重新创建的操作，提高了性能。

这种改进是通过 PatchFlag（补丁标记）和动态指令提供的优化机制实现的。PatchFlag 记录了每个节点的状态，包括是否需要更新、是否需要移动等信息，从而使得 Vue 3 在进行 diff 操作时能够更精确地判断节点的变化，避免了不必要的操作。

需要注意的是，在某些特殊情况下，仍然可能需要设置 key，例如在使用相同的数据集进行多个列表渲染时，或者需要确保列表项的状态保持一致。但是一般情况下，在 Vue 3 中，不再强制要求设置 key 来提高列表渲染的性能，因为新的 diff 算法已经能够更好地处理元素的重新排序。

### 前端框架

所有框架目前的发展方向都是减少客户端 js 代码、减少 js 运行时间。

不管是放到服务端也好、放到编译时也好、抑或是像 signal 这样 fine grained reactivity 也好，都是为了这一个目标努力

- 目前市场出现的 solid.js，svelte 等等都是为了减少 js 代码，减少 js 的运行时间，比如干掉 vdom，干掉 diff
- 但还可以通过 rsc（react-server-component）、ssr（server side rendering）、ssg(static site generation)、isg()

RSC（React Server Component）：

- RSC 是 React 生态系统中的一项实验性功能，用于在服务器上呈现 React 组件。
- RSC 允许在服务器上运行 React 组件，并将其渲染为 HTML，然后将 HTML 发送给客户端进行交互。
- RSC 的目标是提供更好的性能和可维护性，通过在服务器上运行组件逻辑，可以减少网络传输和客户端计算负载。

SSR（Server-Side Rendering）：

- SSR 是一种将 React 或其他前端框架的组件在服务器上进行渲染，并将渲染结果作为 HTML 发送给客户端的技术。
- SSR 的特点是在服务端动态生成完整的 HTML，包括组件内容和初始状态，然后将其发送给客户端。
- SSR 可以提供更好的首次加载性能和搜索引擎优化（SEO），但在每次请求时都需要动态渲染 HTML，可能会增加服务器负载。

SSG（Static Site Generation）：

- SSG 是一种在构建时（而不是在运行时）生成静态 HTML 文件的技术。
- SSG 的特点是在构建过程中预先生成页面的 HTML，将其保存为静态文件，然后在客户端请求时直接提供静态 HTML。
- SSG 可以提供非常快速的加载速度，因为每个页面都是预先生成的，并且不需要服务器进行动态渲染。
  但是，SSG 对于那些包含实时数据或频繁更新的页面可能不太适用，因为它们需要重新构建整个站点才能更新内容。

ISG（Incremental Static Generation）：

- ISG 是一种结合了 SSG 和动态渲染的技术，它允许在构建时生成静态 HTML，并在运行时根据需要增量地更新页面内容。
- ISG 的特点是将一部分页面预先生成为静态 HTML，同时保留一些部分在运行时进行动态渲染。
- 当客户端请求页面时，ISG 可以立即提供静态 HTML，然后在后台异步生成和缓存其他部分的内容，实现增量更新。
- ISG 可以提供更好的性能和用户体验，同时也保留了部分动态内容的灵活性。

Next.js 是一个广泛使用 ISG（Incremental Static Generation）技术的框架。Next.js 是一个基于 React 的前端框架，它提供了强大的静态站点生成功能，允许在构建时生成静态 HTML，并在需要时进行增量更新。

Next.js 提供了一个名为 "getStaticProps" 的特殊函数，用于在构建时获取数据并生成静态 HTML 页面。这样，部分页面的内容可以在构建时预先生成为静态 HTML，而其他部分可以在运行时根据需要进行增量更新。

通过 Next.js 的 ISG 功能，可以实现以下场景：

部分页面内容是静态的，可以在构建时预先生成为静态 HTML。
部分页面内容是动态的，需要在客户端请求时进行渲染。
Next.js 还提供了其他一些优秀的功能，如自动代码分割、服务端渲染（SSR）以及客户端路由等，使得构建现代化、高性能的 Web 应用变得更加方便和高效。

除了上面的一些，其实还有 实现孤岛架构的全栈框架主要是 Astro 与 Qwik

#### vue

Vue.js 使用了一种称为“响应式依赖追踪”的机制来实现响应式更新。
在组件初始化时，Vue.js 会在数据属性上使用 Object.defineProperty 进行劫持，为每个属性创建一个依赖追踪器（Dep）。
当数据属性被读取时，Vue.js 会将当前依赖（如组件的渲染函数）与该属性的依赖追踪器建立关联。
当数据属性发生变化时，Vue.js 会通知相关的依赖，触发相应的更新。

#### react

在 React 中，依赖收集和更新页面的过程是通过 React 的调和（reconciliation）和 diff 算法来实现的。下面是一个简单的描述：

依赖收集：

- 在组件渲染过程中，React 会跟踪组件中使用的状态（如 state 和 props）以及其他上下文（如 context）的读取操作。
- 当组件读取了某个状态或上下文时，React 会将该状态或上下文与当前组件建立关联，形成一个依赖关系。
- React 使用一种称为 "Fiber" 的数据结构来表示组件树，并在 Fiber 节点中记录这些依赖关系。

数据变化和更新页面：

- 当组件中的状态或上下文发生变化时，React 会触发重新渲染过程。
- 在重新渲染过程中，React 会通过比较新旧状态或上下文的值来确定是否需要更新组件。
- React 使用 diff 算法来比较新旧 Fiber 树的差异，并找出需要进行更新的部分。
- 通过 diff 算法，React 可以高效地确定需要添加、移动或删除的 DOM 元素，并生成相应的更新操作。
- 一旦确定了需要更新的部分，React 会根据更新操作对 DOM 进行相应的操作，将页面更新为最新的状态。

需要注意的是，React 并不直接对每个状态或上下文的变化进行监听，而是在组件重新渲染时，通过对新旧状态或上下文的比较，来确定是否需要更新页面。这种基于比较的更新方式可以提高性能，避免了频繁的监听和回调操作。

此外，React 还提供了一些优化手段，如 shouldComponentUpdate、React.memo 和 React.useMemo 等，来帮助开发者更好地控制组件的更新过程，避免不必要的渲染。

- 基于虚拟 DOM（Virtual DOM）实现高效的 UI 更新
- React 使用虚拟 DOM（Virtual DOM）和一种称为协调（Reconciliation）的算法来实现响应式更新。当数据发生变化时，React 会创建一个新的虚拟 DOM 树与之前的虚拟 DOM 树进行比较，找出差异。

然后，React 仅更新发生变化的部分，将这些变化批量应用到实际的 DOM 中，以提高性能

总结：

- react 是使用 setState 来主动通知框架，现在需要更新，然后再根据核心的 view=fn(state) 公式，把发生状态变化的组件及它的 props 发生变化的子组件重新执行一遍，形成新的 vdom，然后才是 diff 之类的
- 这样的效果就是，每次数据发生变更，都需要重新生成对应组件的 vdom
- 相比于 svelte 的 singal 方式，是在编译时，就已经精细化的确定的待更新的范围，后续仅仅更新指定区域即可。

1、svelte 编译时就知道有哪些状态
2、svelte 编译时就知道每个状态对应哪个节点
3、svelte 编译时就知道每个状态何时改变

所以编译器是不是可以针对每个状态的变化，生成更新对应依赖这个状态的节点的代码？
是不是可以在每个状态发生改变的地方下一行插一个语句来触发更新？

#### anglar

#### svelte

Svelte 是一个组件框架，类似于 React 或 Vue，但有一个重要的区别。传统框架允许你编写声明性状态驱动的代码，但有一个缺点：浏览器必须做额外的工作来将这些声明性结构转换为 DOM 操作，使用虚拟 DOM diffing 等技术，这些技术会占用你的帧预算并给垃圾收集器带来负担。

相反，Svelte 在构建时运行，将您的组件转换为高效的命令式代码，以外科手术方式更新 DOM。查看编译后的代码，发现很多都是直接操作 dom。

- Svelte 是一个编译型的前端框架，将组件转换为高效、可复用的纯 JavaScript 代码。
- 在构建时将组件转换为原生的 JavaScript 代码，不需要在运行时进行框架解析和虚拟 DOM 操作。
- 生成的代码体积小、运行快速，适用于对性能要求较高的应用。

```js
// 使用 signal
import { createSignal, onCleanup } from 'svelte';

// 使用 signal 声明一个响应式变量
const [count, setCount] = createSignal(0);

// 定义一个自动更新的计时器
const interval = setInterval(() => {
  setCount(count() + 1);
}, 1000);

// 当组件销毁时清除计时器
onCleanup(() => {
  clearInterval(interval);
});

// Svelte 组件模板
<script>
  export let count;
</script>

<h1>Count: {count}</h1>
```

下面是不使用 singal

```js
import { reactive, onCleanup } from 'svelte';

// 创建一个普通的 reactive 对象
const state = reactive({
  count: 0,
});

// 定义一个自动更新的计时器
const interval = setInterval(() => {
  state.count += 1;
}, 1000);

// 当组件销毁时清除计时器
onCleanup(() => {
  clearInterval(interval);
});

// Svelte 组件模板
<script>
  export let count;
</script>

<h1>Count: {state.count}</h1>
```

这两个示例代码展示了使用 signal 和不使用 signal 的方式来实现一个计时器。使用 signal 可以更显式地声明依赖关系，并且在更新时只更新变化的部分。而不使用 signal 则是一种更传统的响应式方式，直接修改属性值来触发更新。

#### solid.js

- 无虚拟 DOM：与传统的虚拟 DOM 不同，Solid.js 采用了一种叫做“fine-grained reactivity”的方法。它使用细粒度的响应追踪和直接的 DOM 更新，以减少不必要的开销，提高渲染性能。
- 响应式：Solid.js 支持响应式编程，通过追踪数据的依赖关系，实现了高效的重新渲染机制。只有发生变化的部分会被更新，从而提供了更好的性能。

- Solid.js 使用了一种称为“细粒度响应追踪”的方法来实现响应式更新。
- Solid.js 通过追踪 JavaScript 表达式中的数据依赖关系，而不是追踪整个组件树的变化。
- 当数据发生变化时，Solid.js 可以精确地确定哪些表达式依赖于该数据，并仅更新相关的部分。
- Solid.js 采用直接的 DOM 更新方式，而不使用虚拟 DOM，以减少不必要的开销，提高渲染性能。

### 跨端方案

早期 H5 和 Hybrid 方案的本质是，利用客户端 App 的内置浏览器（也就是 webview）功能，通过开发前端的 H5 页面满足跨平台需求。比如 PhoneGap cordova ionic

#### weex

Weex 采用了一种将组件树转换为原生控件的方式进行渲染。在运行时，Weex 的渲染引擎会解析组件树，并通过与底层的原生渲染引擎进行通信，将组件映射为对应的原生控件。

Weex 的渲染原理中，底层的原生渲染引擎负责实际的 UI 渲染工作，Weex 的渲染引擎充当一个中间层，负责转发指令和数据更新等操作。

和目前小程序很像

#### react native

使用 React 来创建 Android 和 iOS 的原生应用

React Native 使用了一种桥接机制（Bridge），它的作用是将 React 组件映射到对应的原生控件。这意味着 React Native 应用的界面并非完全由原生控件构成，而是在原生应用中嵌入了一个特殊的视图层，该视图层负责处理 React 组件的渲染和交互。

当 React 组件需要在屏幕上显示时，React Native 的桥接机制会将组件的描述信息传递给原生层。原生层根据这些描述信息，去创建对应的原生控件，并将这些控件放置在正确的位置上，形成了组件在屏幕上的可见部分。

#### flutter

Flutter 使用自绘引擎进行渲染，也称为 Skia 渲染引擎。它通过使用自定义的渲染引擎，绕过了原生平台的 UI 组件，直接在屏幕上绘制 UI。

Flutter 的自绘引擎使用 Skia 图形库进行绘制，将所有的 UI 组件都抽象为绘制指令，并通过硬件加速来实现高性能的图形渲染。

Weex 和 Flutter 在性能方面有所不同。**Weex 的渲染引擎需要与原生渲染引擎进行通信，可能会引入一定的性能开销**。而 Flutter 的自绘引擎能够直接操作底层图形库，具有较高的渲染性能。

### 编译型语言

- rust
  - 类似 c++，可直接操作底层，更快，没运行环境，gc 需要手动维护
  - Rust 速度惊人且内存利用率极高。由于没有运行时和垃圾回收，它能够胜任对性能要求特别高的服务，可以在嵌入式设备上运行，还能轻松和其他语言集成。
    - 高性能：rust 没有运行环境，指的是 rust 编译后生成的二进制文件不依赖于任何运行时环境，而 js 则需要运行时环境。
    - 可靠性：Rust 引入了所有权系统和借用检查器，生命周期等机制。这些机制使编译器能够在编译期间进行静态分析，确保没有数据竞争和内存访问错误。通过在编译时处理内存管理，Rust 可以避免动态运行时的开销和垃圾回收带来的性能损失。
- go
  - esbuild
  -

### 构建工具

- webpack
  - 插件，loader
- vite
  - 在浏览器支持 ES 模块之前，JavaScript 并没有提供原生机制让开发者以模块化的方式进行开发。
  - 使用 ES 模块原生模块，将模块的依赖关系推迟到浏览器运行时，使得启动阶段很快
  - 预构建：vite 会使用 esbuild 预构建那些第三方包，首次访问某个模块时，将该模块独立地构建为一个包，并缓存起来
  - 按需编译：Vite 只编译那些被当前页面所需要的模块，这是因为它依赖于浏览器的 ES 模块加载能力，将模块的依赖关系推迟到了浏览器运行时
    - 这样，当浏览器请求一个模块时，Vite 可以根据实际需要，仅构建该模块及其相关的依赖模块，而无需重新构建整个项目
    - 而 webpack 将所有模块打包成一个或多个捆绑包，以便在浏览器中加载，无法实现精确的按需编译
  - 缓存：将编译好的资源缓存起来
  - HMR：只替换变更的地方，最小化改动。
  - 为什么生产环境依然需要打包
    - 尽管原生 ESM 现在得到了广泛支持，但由于**嵌套导入会导致额外的网络往返**，在**生产环境中发布未打包的 ESM 仍然效率低下（即使使用 HTTP/2）**
  - 为什么不用 esbuild 打包
    - Vite 目前的插件 API 与使用 esbuild 作为打包器并不兼容
    - Rollup 已经开始着手改进性能，在 v4 中将其解析器切换到 SWC。就可以在 Vite 中取代 Rollup 和 esbuild，显著提高构建性能，并消除开发和构建之间的不一致性
    - SWC 通过利用 Rust 语言的优势和并行处理技术，实现了出色的编译性能，可以取代 babel，侧重于编译器，而 esbuild 是打包器。
- rollup
- parcel
- esbuild
  - go
- respack
  - rust
- swc
  - rust

## 20231130 周四

### 找出数组中不同的值

```js
const difference = (arr1, arr2) => {
  const map = {}
  const res = []
  arr1.forEach((v) => (map[v] = v))

  arr2.forEach((v) => {
    if (map[v] === void 0) {
      res.push(v)
    } else {
      delete map[v]
    }
  })
  return res.concat(Object.values(map))
}
difference([2, 1], [2, 3]) // [3, 1]

const difference = (arr1, arr2) => {
  const map = {}
  arr1.forEach((v) => (map[v] = v))

  return arr2.reduce((acc, cur) => {
    if (map[cur] === void 0) {
      acc.push(cur)
    } else {
      // 删除多余的
      delete map[cur]
    }
    console.log('djch acc', acc)
    // 拼接之前的，然后再去重
    return [...new Set(acc.concat(Object.values(map)))]
  }, [])
}
difference([2, 1], [2, 3])

const difference = (arr1, arr2) => {
  const map = {}
  arr1.forEach((v) => (map[v] = v))

  arr2.forEach((v) => {
    if (map[v] === void 0) {
      map[v] = v
    } else {
      delete map[v]
    }
  })
  return Object.values(map)
}
difference([2, 1], [2, 3]) // [1, 3]
```

### 作用域

```js
function bar() {
  console.log(myName)
}
function foo() {
  var myName = '极客邦'
  bar()
}
var myName = '极客时间'
foo() // 极客时间
```

其实在每个执行上下文的变量环境中，都包含了一个外部引用，用来指向外部的执行上下文，我们把这个外部引用称为 outer。当一段代码使用了一个变量时，JavaScript 引擎首先会在“当前的执行上下文”中查找该变量，如果在当前的变量环境中没有查找到，那么 JavaScript 引擎会继续在 outer 所指向的执行上下文中查找。我们把这个**通过作用域查找变量的链条叫做作用域链，切记切记：作用域链的顺序与执行栈的顺序不一定相同**

作用域链：通过作用域查找变量的链条，而作用域可以理解为执行上下文。但和调用栈的顺序还不相同

**那这个作用域链的顺序是由什么确定的呢**？

答案是：词法作用域，词法作用域就是指作用域是由代码中**函数声明的位置**来决定的，所以词法作用域是静态的作用域，通过它就能够预测代码在执行过程中如何查找标识符。而词法作用域是代码阶段就决定好的，和函数是在哪调用的没有关系。

因此上面 bar 函数虽然在 foo 函数内部调用的，**但 bar 定义在全局，因此依然去全局执行上下文的变量环境中去找 myName。**

在 JavaScript 中，根据词法作用域的规则，内部函数总是可以访问其外部函数中声明的变量，当通过调用一个外部函数返回一个内部函数后，即使该外部函数已经执行结束了，但是内部函数引用外部函数的变量依然保存在内存中，我们就把这些变量的集合称为闭包。比如外部函数是 foo，那么这些变量的集合就称为 foo 函数的闭包。

### 变量提升

```js
showName()
var showName = function () {
  console.log(2)
}
function showName() {
  console.log(1)
}
```

### 堆栈溢出

因为 V8 并不是一个完整的系统，所以在执行时，它的一部分基础环境是由宿主提供的，这包括了全局执行上下文、事件循环系统，堆空间和栈空间。除了需要宿主提供的一些基础环境之外，V8 自身会提供 JavaScript 的核心功能和垃圾回收系统。

宿主环境在启动过程中，会构造堆空间，用来存放一些对象数据，还会构造栈空间，用来存放原生数据。由于堆空间中的数据不是线性存储的，所以堆空间可以存放很多数据，**但是读取的速度会比较慢，而栈空间是连续的，所以栈空间中的查找速度非常快，但是要在内存中找到一块连续的区域却显得有点难度，于是所有的程序都限制栈空间的大小，这就是我们经常容易出现栈溢出的一个主要原因。**

```js
function getStackDepth() {
  let depth = 0

  function recursiveCall() {
    depth++
    recursiveCall()
  }

  try {
    recursiveCall()
  } catch (error) {
    // 捕获堆栈溢出错误
    // 在这里可以根据需要进行处理
  }

  return depth
}

const stackDepth = getStackDepth()
console.log('Stack depth:', stackDepth) // 9177 这个东西不是一定的，在node环境深度为：10514
```

## 20231128 周二

### 设计一个全栈系统需要考虑哪些

- 架构设计：确定系统的整体架构，包括前端与后端之间的通信方式和数据传输格式。常见的选择包括 RESTful API、GraphQL 等。确保前后端之间的接口设计合理、清晰，并能够满足系统需求。

- 数据流管理：选择合适的状态管理方案，例如 Vue 中的 Vuex，用于管理前端应用程序的状态和数据流。考虑前端与后端之间的数据交互，如何将后端返回的数据同步到前端的状态管理中，以及如何将前端的用户操作发送给后端进行处理。

- 接口设计：设计后端的 API 接口，定义请求和响应的数据结构、参数验证、错误处理等。确保接口设计符合 RESTful 原则或其他约定，并能够满足前端的数据需求。

- 安全性：确保系统的安全性，包括前端与后端的身份验证和授权机制，防止潜在的安全漏洞和攻击。使用适当的安全性措施，如 HTTPS、跨站脚本攻击（XSS）防护、跨站请求伪造（CSRF）防护等。

- 性能优化：考虑系统的性能优化，包括前端的加载速度、渲染性能以及后端的响应时间和吞吐量。使用合适的技术和工具，如前端的代码压缩、缓存机制、懒加载等，后端的数据库索引、缓存、异步处理等。

- 日志和监控：配置适当的日志记录和监控系统，用于收集系统的运行日志和性能指标。这样可以方便排查问题、监控系统运行状态，并及时发现和解决潜在的异常情况。

- 部署和运维：考虑系统的部署和运维流程，包括前端的打包和发布、后端的部署和扩展。选择合适的部署方式，如容器化部署（如 Docker）、自动化部署工具（如 Jenkins）等，以便更高效地进行系统的部署和维护。

- 测试和质量保证：建立适当的测试策略和流程，包括单元测试、集成测试、端到端测试等，以确保系统的质量和稳定性。使用合适的测试工具和框架，如 Jest、Mocha 等，进行全面的测试覆盖。

### 微前端、微服务

- 微前端：微前端是一种类似于微服务的架构，是一种由独立交付的多个前端应用组成整体的架构风格，将前端应用分解成一些更小、更简单的能够独立开发、测试、部署的应用，而在用户看来仍然是内聚的单个产品。有一个基座应用（主应用），来管理各个子应用的加载和卸载。
- 是一种后端架构模式，将一个大型应用程序拆分为一组小型、自治的服务，每个服务独立运行、部署和扩展。每个服务负责特定的业务功能，可以由独立的团队开发和维护，使用适合其需求的编程语言和技术栈。微服务通过解耦和自治的服务架构，提高了系统的可扩展性、灵活性和可维护性。微服务之间通过 API 进行通信，可以使用轻量级的通信协议（如 HTTP、REST）或消息队列等方式。
- Serverless（无服务器）是一种云计算架构模式，它使开发者能够构建和运行应用程序而无需管理底层的服务器基础设施。在传统的服务器模型中，开发者需要自行配置、管理和扩展服务器。而在 Serverless 模型中，云服务提供商负责管理底层的服务器资源，开发者只需关注应用程序的业务逻辑。

  - 事件驱动：Serverless 应用程序是通过事件触发的，例如 HTTP 请求、消息队列、数据库变更等。开发者编写函数（Function）来处理这些事件，并将函数上传到云平台，云平台会在事件发生时自动执行函数。
  - 弹性扩展：Serverless 平台根据事件的负载自动进行弹性扩展，根据需要分配和释放资源，使应用程序能够适应不同的负载情况。
  - 付费模型：
  - 服务管理：云服务提供商负责管理底层的服务器基础设施，包括服务器的配置、部署、监控和日志记录等，开发者只需专注于应用程序的开发。

- 为什么不是 iframe
  - iframe 最大的特性就是提供了浏览器原生的硬隔离方案，不论是样式隔离、js 隔离这类问题统统都能被完美解决。
  - 但最大的问题，同样也在于他的隔离性无法被突破，导致应用间上下文无法被共享，随之带来的开发体验、产品体验的问题。
    - url 不同步。浏览器刷新 iframe url 状态丢失、后退前进按钮无法使用。
    - UI 不同步，DOM 结构不共享。想象一下屏幕右下角 1/4 的 iframe 里来一个带遮罩层的弹框，同时我们要求这个弹框要浏览器居中显示，还要浏览器 resize 时自动居中..
    - 全局上下文完全隔离，内存变量不共享。iframe 内外系统的通信、数据同步等需求，主应用的 cookie 要透传到根域名都不同的子应用中实现免登效果
    - 慢。每次子应用进入都是一次浏览器上下文重建、资源重新加载的过程。

### 实现一个简易的模版引擎

顾名思义，其实就是解析模版而已

```js
function render(template, data) {
  const regex = /{{\s*([a-zA-Z0-9_.]+)\s*}}/g
  return template.replace(regex, (match, key) => {
    const keys = key.split('.')
    let value = data
    for (let k of keys) {
      value = value[k]
    }
    return value !== undefined ? value : match
  })
}

const template = 'Hello, {{ name }}! Today is {{ date.month }} {{ date.day }}.'

const data = {
  name: 'John Doe',
  date: {
    month: 'September',
    day: 28,
  },
}

const result = render(template, data)
console.log(result)
// 输出: "Hello, John Doe! Today is September 28."
```

### 发布订阅

```js
// 发布订阅
class MyEvtEmitter {
  constructor() {
    this.map = new Map()
  }

  // 添加事件
  on(key, fn) {
    // 之前存在过，就压入
    if (this.map.has(key)) {
      this.map.get(key).push(fn)
    } else {
      this.map.set(key, [fn])
    }
  }

  // 触发事件
  emit(key) {
    if (!this.map.has(key)) {
      return '事件未定义'
    }

    this.map.get(key).forEach((fn) => fn())
  }

  del(key) {
    this.map.has(key) && this.map.delete(key)
  }

  once(key, fn) {
    const _fn = () => {
      // 执行完，就移除对应事件
      fn()
      this.del(key)
    }
    this.on(key, _fn)
  }
}
```

### LRU 缓存

```js
// 最大size
//
class myLRU {
  constructor(size) {
    this.maxSize = size
    this.map = new Map()
  }
  get(key) {
    if (!this.map.has(key)) {
      return -1
    }

    // 如果存在，则找到，并重新更新
    const val = this.map.get(key)
    this.del(key)
    this.set(key, val)
  }

  set(key, val) {
    // 如果有，直接删除
    if (this.map.has(key)) {
      this.del(key)
    }

    // 判断是否超过限制
    if (this.map.size >= this.maxSize) {
      // 删除最后一个, this.map.keys() 生成一个迭代器
      // 迭代器调用next方法，得到对应的值，value就是对应的key
      this.del(this.map.keys().next().value)
    }
    this.map.set(key, val)
  }
  del(key) {
    this.map.delete(key)
  }
}

const cLru = new myLRU(2)
cLru.set('a', '111')
cLru.get('a')

// cLru.map.keys().next()
// {value: 'a', done: false}
```

### `console.log(1<2<3)`

- 1 < 2 返回 true
- true < 3 进行比较时，又会转化为 1 < 3 最后返回 true

### 写一个 lodash 的 get 方法

```js
const myGet = (obj, str, defaultValue) => {
  // str 肯定是字符串
  if (str === void 0) return obj

  return str.split('.').reduce((acc, cur) => {
    return acc[cur] ? acc[cur] : defaultValue || ''
  }, obj)
}

function myGet1(obj, path, defaultValue) {
  // 判断是数组还是
  const keys = Array.isArray(path) ? path : path.split('.')
  let result = obj

  // 遍历数组
  for (let key of keys) {
    // 如果
    if (result && typeof result === 'object' && key in result) {
      result = result[key]
    } else {
      return defaultValue
    }
  }

  return result
}

// myGet({a: { b: 1 }}, 'a.b')
myGet1({ a: { b: 1 } }, 'a.b')
```

## 20231124 周五

### 有序数组的平方

```js
var sortedSquares = function (nums) {
  // 利用双指针
  let left = 0
  let right = nums.length - 1

  // 然后生成一个空数组，作为结果数组
  let res = Array(nums.length).fill(0)
  let k = nums.length - 1

  while (left <= right) {
    let a = nums[left] * nums[left]
    let b = nums[right] * nums[right]

    if (a < b) {
      // 将最大的放在最右侧，因为负负得正，最大值肯定在两侧
      // 另外注意，需要新增一个指针和数组，作为最终操作的，不要使用left、right、nums等，防止干扰
      res[k--] = b
      right--
    } else {
      res[k--] = a
      left++
    }
  }
  return res
}
```

### 翻转字符串

- 每隔 2k 项，翻转前 k 项

```js
var reverseStr = function (s, k) {
  // 思路：仔细审题，其实就是，将字符串分割成每2k为一组，然后翻转这一组中的前k项
  // 因此，只需要在for循环上做文章即可

  let len = s.length
  // 不要直接操作字符串，
  let resArr = s.split('')
  for (let i = 0; i < len; i += 2 * k) {
    // 找出最右侧边界
    let l = i
    let r = i + k - 1 > len ? len : i + k - 1

    while (l < r) {
      ;[resArr[l], resArr[r]] = [resArr[r], resArr[l]]
      l++
      r--
    }
  }
  return resArr.join('')
}
```

### 手写一个 new 运算符

- new 运算符是实例化一个函数，然后得到一个实例
  - 创建一个对象
  - 让对象的原型等于函数的原型
  - 执行函数
  - 判断返回值

```js
function Foo() {
  console.log('foo')
}
Foo.prototype.sayHi = () => console.log('hi')

let o = new Foo()

// 等价于
function myNew() {
  // var o = Object.create(null);   //1、新建空对象，这里不要使用这个，因为会断掉一些链接
  var o = new Object() //1、新建空对象
  o.__proto__ = Foo.prototype //2、建立连接
  let returnVal = Foo.call(o) //3、执行
  if (typeof returnVal === 'object') {
    //4、判断返回值
    return returnVal
  }
  return o
}
```

### js 中 this 的指向

```js
// 因为在ES5中，全局变量是挂载在顶层对象（浏览器是window）中
var name = 'window'
var doSth = function () {
  console.log(this.name)
}
doSth() // window

// let没有给顶层对象中（浏览器是window）添加属性，window.name2和window.doSth都是undefined。
let name1 = 'window'
let doSth = function () {
  console.log(this === window)
  console.log(this.name1)
}
doSth() // true，undefined
```

### 大数字相乘

```js
var multiply = function (num1, num2) {
  // 如果没有这个判断，会超时
  if (num1 === '0' || num2 === '0') {
    return '0'
  }
  // 字符串相加的话，只需要进一次位，相乘则可能进位多次。。。
  // 两个数相乘，最大位数是 m + n
  // 倒序遍历两个数,

  const len1 = num1.length
  const len2 = num2.length
  const res = Array(len1 + len2).fill(0)

  // 这里其实是双层循环，拿一个数分别乘以另外一个数字的全部位
  for (let i = len1 - 1; i >= 0; i--) {
    const a = +num1[i]
    for (let j = len2 - 1; j >= 0; j--) {
      const b = +num2[j]
      const multi = a * b // 字符串相乘，直接变成数组
      const sum = res[i + j + 1] + multi //

      res[i + j + 1] = sum % 10
      // 数组的每一项，可以是多个位数
      // 注意这里是 res[i + j] = res[i + j] + sum / 10 | 0
      res[i + j] += (sum / 10) | 0
    }
  }
  // 去除头部0
  while (!res[0]) res.shift()

  return res.length ? res.join('') : '0'
}
```

### 大数字相加

```js
// 两个大数相加
var addStrings = function (num1, num2) {
    let result = '';
    let i = num1.length - 1, j = num2.length - 1, carry = 0;

    while (i >= 0 || j >= 0) {
        let n1 = i >= 0 ? +num1[i] : 0;
        let n2 = j >= 0 ? +num2[j] : 0;
        const temp = n1 + n2 + carry;
        // 🔥注意这里：与0按位或，产生的效果是把小数部分干掉了
        // 其实本质是 在位操作符 | 在执行之前会将浮点数 xxx 转换为32位 🔥带符号整数🔥 。转换过程中，整数部分保持不变，小数部分被截断。
        // 而后面的0就是一个陪衬，相比与 Math.floor 是向下取整，二者的含义不一样
        carry = temp / 10 | 0;
        result = `${temp % 10}${result}`;
        i--; j--;
    }
    // 处理最后一个进位
    if (carry === 1) result = `1${result}`;

    return result;
};

// 关于进制转化 ：小数部分可以通过乘以 2 并提取整数部分的方式逐步转换为二进制
0.58 * 2 = 1.16   // 整数部分为 1
0.16 * 2 = 0.32   // 整数部分为 0
0.32 * 2 = 0.64   // 整数部分为 0
0.64 * 2 = 1.28   // 整数部分为 1
0.28 * 2 = 0.56   // 整数部分为 0
0.56 * 2 = 1.12   // 整数部分为 1

// 重复上述步骤，直到小数部分为 0，或者达到所需的精度。在这个例子中，我们可以选择保留小数点后面的位数。
// 因此，`0.58` 的二进制表示为 `0.1001011001...`（无限循环）。
```

### 什么是闭包？

```js
// 函数内部创建的函数以及该函数能够访问的外部函数作用域中的变量的组合
```

### NaN null

```js
// 在基础库里，在经过bridge时会序列化导致 NaN 变为了，字符串的 'null'
JSON.stringify(NaN) // 'null'
JSON.parse(JSON.stringify(NaN)) // null

// 而组件在处理props时，又会根据type类型做处理
val === null ? '' : String(val)
```

### IIFE (Immediately Invoked Function Expressions)

```js
// function foo(){ }()  // 会报错，会被解析成函数定义和 () 而调用有没有具体的函数名

// 在执行时，函数表达式 (function foo(){ }) 被立即调用，函数名 foo 在函数外部是不可见的
// 🔥 foo执行完就会立即释放
// 由于自执行函数在定义时就被立即调用，它的主要目的通常是为了创建一个局部作用域，以避免变量污染全局命名空间
;(function foo() {})()(function foo() {})()
```

### a == 1 && a == 2 && a ==3

```js
// 可以使用代理，也可以使用对象的valueOf方法
var a = {
  value: [1, 2, 3],
  // valueOf() 方法。该方法在进行隐式类型转换时被调用
  valueOf: this.value.shift(),
}

// 比较 a == 1。由于 a 是一个对象，而 1 是一个数字，JavaScript 会尝试将对象 a 转换为一个原始值进行比较。这时会调用 a 的 valueOf() 方法
console.log(a == 1 && a == 2 && a == 3) // true
```

### 编写一个函数，解析一个树状结构里的值

```js
var arr = [1, [2, 3, [4, 5, [6, 6]]]]

const formatArr = (data) => {
  const flatArr = data.flat(Infinity)
  const noRepeatArr = [...new Set(flatArr)]
  return noRepeatArr.sort((a, b) => b - a)
}

const formatArrV1 = (data) => {
  // 针对数组做序列化，会自动拍平，注意是String，不是JSON.stringify
  // const flatArr = JSON.stringify(data) // '[1,[2,3,[4,5,[6,6]]]]'
  // String([1,[2,3,[4,5]]]) => '1,2,3,4,5'
  const flatArr = String(data)
    .split(',')
    .map((v) => +v)
  const noRepeatArr = flatArr.filter((v, idx, arr) => idx === arr.indexOf(v))
  return noRepeatArr.sort((a, b) => b - a)
}

console.log(formatArr(arr))
```

### 编写一个函数，解析嵌套对象里的值

```js
var obj = {
  'a.b.c': 1,
  'a.d.e': 2,
}
// 最后输出
var result = {
  a: {
    b: { c: 1 },
    d: { e: 2 },
  },
}

// 思路，关键点在于如何将新生成的对象，挂载到之前的属性上
var obj = { 'a.b.c': 1, 'a.c.d': 2 }
function formatObj(data) {
  let res = {}

  for (const key in data) {
    if (data.hasOwnProperty(key)) {
      const keyArr = key.split('.')

      // 因为res是最终结果，需要一个动态指针，类似链表里，一个head不动，然后操作一个游动指针
      let tempRes = res

      // 需要判断最后一个值，
      keyArr.forEach((k, idx) => {
        // 如果是最后一个，则赋值
        if (idx === keyArr.length - 1) {
          tempRes[k] = data[key]
        } else {
          // 此时需要新建对象，不需要复制
          tempRes[k] = tempRes[k] || {}
          // 指针移动，因为下一个的值，肯定是挂载在 tempRes[k] 的
          tempRes = tempRes[k]
        }
      })
    }
  }
  return res
}
console.log(formatObj(obj))
```

## 20231123 周四

### 事件循环队列

- 注意主线程，比如各个生命周期的执行，即使 onLoad 里有 await 函数，也不会阻断 onShow 的执行 如下
  - 因为内部的任务可以理解为当前主线程的宏任务或者微任务，只会阻断当前生命周期内部的逻辑
  - 那这样的话，页面初始化，按理说不应该渲染的慢啊？？？
- 微任务注册是有顺序的，如果前一个微任务没有执行，则它接下来的那个微任务肯定也不会注册

```js
onLoad()
onShow()
```

### promiseLimit

思路：

1. 一个函数负责往里面添加执行函数
2. 另外一个函数，负责执行具体的任务

```js
const promiseLimit = (ps, limit) => {
  const res = []
  let runing = 0
  let idx = 0
  let len = ps.length

  return new Promise((resolve, reject) => {
    const runTask = (p, index) => {
      runing++
      console.log('正在执行的数量', runing)
      p()
        .then((v) => {
          runing--
          res[index] = v

          // 任务执行完，继续触发walk
          walk()
        })
        .catch((err) => reject(err))
    }

    const walk = () => {
      // 如果正在执行的小于limit，且已经执行的总数小于 len
      while (runing < limit && idx < len) {
        runTask(ps[idx], idx)
        idx++
      }
      // 如果执行完，则resolove
      if (!runing) resolve(res)
    }
    walk()
  })
}
```

## 20231122 周三

### 合并乱序区间

### 手动实现一个 vue 的数据劫持

思路：其实就是递归 + Object.defineProperty 或者 proxy

```js
const observe = (obj) => {
  // 只针对对象做响应式拦截
  if (!obj || typeof obj !== 'object') return

  // 遍历对象属性
  Object.keys(obj).forEach((key) => {
    let val = obj[key]

    // 递归处理
    observe(val)

    // 处理具体值
    Object.defineProperty(obj, key, {
      enumerable: true, // 可枚举
      configurable: true, // 可修改
      get() {
        console.log('访问属性', key, '值为', val)
        return val
      },
      set(newVal) {
        if (newVal === val) return
        console.log('设置属性', key, '新值为', newVal)
        val = newVal
      },
    })
  })
}

var obj = {
  a: 1,
  b: { c: 'cc', d: 3 },
}
observe(obj)
obj.a //

// 使用Proxy
const observeProxy = (obj) => {
  // 其实就是针对一个对象，做一个配置化的处理
  return new Proxy(obj, {
    get(target, key) {
      console.log('访问属性', key, '值为', target[key])
      if (key in target) {
        return target[key]
      }
    },
    set(target, key, val) {
      target[key] = val
      console.log('设置属性', key, '值为', target[key])
      return true // 必须返回true
    },
    deleteProperty(target, key) {
      console.log('删除属性', key)
      delete target[key]
      return true // 必须返回true
    },
  })
}
var newObj = observeProxy(obj)
newObj.a
```

- Proxy
  - 功能更强大，可以拦截更多的操作，包括属性读取、属性设置、属性删除、函数调用等
  - 直接代理整个对象，而不是每个属性，可以动态处理添加和删除的属性
  - 代理对象，还可以拦截对象的方法调用和构造函数调用
  - 缺点：兼容性、性能开销稍高
- Object.defineProperty
  - 兼容性好
  - 精细化控制，具体每个属性的可枚举、可配置、可写等
  - 只针对已存在的属性
  - 无法拦截整个对象

### 原生实现 ajax

思路：利用 promise，封装 XMLHttpRequest 方法

### 判断二叉树是否为对称二叉树

- 思路：成对压入堆栈，注意顺序，然后再成对弹出，判断

```js
var isSymmetric = function (root) {
  if (!root) return true

  const stack = [root.left, root.right]
  while (stack.length) {
    const right = stack.pop()
    const left = stack.pop()

    // 如果二者都没有，则继续
    if (!right && !left) {
      continue
    }
    if (!right || !left) {
      return false
    }
    if (right.val !== left.val) {
      return false
    }

    // 成对压入堆栈，注意顺序，不需要考虑有没有值
    stack.push(left.left, right.right)
    stack.push(left.right, right.left)
  }
  return true
}
```

### 进制转化

考察点

- 位操作运算
- toString、parseInt 操作
  - parseInt 只是根据指定的 radix 进制数，**识别字符串中对应进制的数据**而已，默认 10。如果不是对应进制，则停止识别
    - 默认 10 进制
  - toString
    - 字符串，原样返回
    - 数字类型，可以接收一个进制数，进而转到对应进制
    - 对于数组，将数组中每个元素转为字符串，然后,号拼接
      - 🔥🔥🔥🔥 [1,3, [3,4, [3,4]]].toString() => '1,3,3,4,3,4' 可以利用这个特性拍平数组啊。。。
    - 对象，返回"[object Object]"

```js
parseInt(234, 4) // 11 ，因为4进制，最高位就是4，所以只能识别到 23 也就是 2 * 4 + 3 => 11
;(12).toString(10) // // 12
;(12).toString(8) // 14 , 1 * 8 + 4 => 12
;[(1, 3, [3, 4, [3, 4]])].toString() // '1,3,3,4,3,4'
```

如何手动实现一个进制转化呢？

我们要知道，所谓进制转化，其实就是将某个数 以某个 base 基数进行拆分而已

```js
function decimalToBase(decimalNumber, base) {
  if (base < 2 || base > 16) {
    throw new Error('Base out of range. Only supports base 2 to 16.')
  }

  const digits = '0123456789abcdef'
  const result = []

  while (decimalNumber > 0) {
    // 取余得到 进位，也就正好映射 digits 里的数据
    const digit = decimalNumber % base
    result.unshift(digits[digit]) // 从前到后压入
    decimalNumber = Math.floor(decimalNumber / base) // 除数，得到最新的值。
  }

  return result.join('')
}

const decimalNumber = 42
const binaryNumber = decimalToBase(decimalNumber, 2)
const octalNumber = decimalToBase(decimalNumber, 8)
const hexadecimalNumber = decimalToBase(decimalNumber, 16)

console.log(binaryNumber) // Output: "101010"
console.log(octalNumber) // Output: "52"
console.log(hexadecimalNumber) // Output: "2a"
```

上面知道进制转化，那颜色转化是不是就清晰了

- rgb 格式：rgb(255, 121, 245)
- 16 进制：00ff00

```js
function rgbToHex(r, g, b) {
  // 最后的字符串 00ff00 高位在最左侧
  // 然后每个rgb，其实都是 2 的 8次方以内，也就是一个字节 8 位，然后把rgb平铺到二进制位上，然后得出一个总的二进制数，然后再转成 16进制
  let rgbStr = ((r << 16) | (g << 8) | b).toString(16)
  // console.log('rgbStr', rgbStr)
  // (15).toString(16)  // 'f'

  // return '0x' + rgbStr.padStart(6, 0)
  return '0x' + `000000${rgbStr}`.slice(-6) // 从倒数第6个开始截取
}
```

### 数组常见方法

```js
// 拍平，转数字，去重，排序
var arr = [1, 3, [3, 4, [3, 4]]]
const res = arr
  .toString()
  .split(',')
  .map((item) => +item)
  .filter((item, idx, arr) => idx === arr.indexOf(item))
  .sort((a, b) => b - a)
console.log(res) // [4, 3, 1]

// 拍平数组
const nestedArray = [1, [2, [3, 4]]]
const flattenedArray = nestedArray.flat() // [1, 2, [3, 4]]  默认深度一
const flattenedArray = nestedArray.flat(Infinity) // 大于则自动最深

// reduce
const numbers = [1, 2, 3, 4, 5, [1, 3]]

const flattenV1 = (arr) => {
  return arr.reduce((res, ele) => {
    return res.concat(Array.isArray(ele) ? flattenV1(ele) : ele)
  }, [])
}
console.log(flattenV1(numbers))

// 利用递归
const flatArray = (arr, res = []) => {
  arr.forEach((item) => {
    if (Array.isArray(item)) {
      // 注意这里，是将res传入
      flatArray(item, res)
    } else {
      res.push(item)
    }
  })
  return res
}

// 利用迭代
function flattenArrayIterative(arr) {
  const stack = [...arr]
  const result = []
  while (stack.length) {
    const next = stack.pop()
    if (Array.isArray(next)) {
      stack.push(...next)
    } else {
      result.unshift(next)
    }
  }
  return result
}
```

### 动态规划

#### 斐波那契数列

```js
var fib = function (n) {
  // 动态规划
  // 1、定义dp：dp[i]表示第i项的斐波那契数
  // 2、定义公式：dp[i] = dp[i-1] + dp[i-2]
  // 3、确定遍历顺序：从小到大
  // 4、初始化：dp = [0, 1]
  // 5、推导

  const dp = [0, 1]
  for (let i = 2; i <= n; i++) {
    dp[i] = dp[i - 1] + dp[i - 2]
  }
  return dp[n]
}
```

#### 爬楼器

爬到第一层楼梯有一种方法，爬到二层楼梯有两种方法。

那么第一层楼梯再跨两步就到第三层 ，第二层楼梯再跨一步就到第三层。

所以到第三层楼梯的状态可以由第二层楼梯 和 到第一层楼梯状态推导出来，那么就可以想到动态规划了。

```js
var climbStairs = function (n) {
  // dp[i] 为第 i 阶楼梯有多少种方法爬到楼顶
  // dp[i] = dp[i - 1] + dp[i - 2]
  let dp = [1, 2]
  for (let i = 2; i < n; i++) {
    dp[i] = dp[i - 1] + dp[i - 2]
  }
  return dp[n - 1]
}
```

### 贪心

#### 跳跃游戏

其实跳几步无所谓，关键在于可跳的覆盖范围，是否能达到终点。

贪心算法局部最优解：每次取最大跳跃步数（取最大覆盖范围），整体最优解：最后得到整体最大覆盖范围，看是否能到终点。

局部最优推出全局最优，找不出反例，试试贪心！

因此每次移动都更新最大覆盖范围即可。

```js
var canJump = function (nums) {
  // 更新最大跳跃范围即可
  let cover = 0 // 定义可覆盖范围
  // 下面循环的变量不对，应该是cover的长度，因为只有cover你才可以到达
  // for (let i = 0; i <= nums.length; i++) {
  for (let i = 0; i <= cover; i++) {
    cover = Math.max(i + nums[i], cover)
    if (cover >= nums.length - 1) {
      return true
    }
  }
  return false
}
```

### 回溯

- for 循环，相当于横向选择，选择同一层的元素
  - 每次从集合中选取元素，可选择的范围随着选择的进行而收缩，调整可选择的范围。
  - 而如何通过标识缩小范围内，就是通过 索引 index
- 而回溯就是纵向选择，二者结合后，就可以遍历整个树
- 回溯法就是解决这种 k 层 for 循环嵌套的问题。

```js
for (int i = startIndex; i <= n; i++) { // 控制树的横向遍历
    path.push_back(i);         // 处理节点
    backtracking(n, k, i + 1); // 递归：控制树的纵向遍历，注意下一层搜索要从i+1开始，也就缩小了范围
    path.pop_back();           // 回溯，撤销处理的节点
}
```

## 20231121 周二

### 二叉树

#### 二叉树的所有路径

```js
function binaryTreePaths(root) {
  if (!root) return []
  const res = [],
    stack = [root],
    paths = ['']

  while (stack.length) {
    // 节点和path是成对存在
    const node = stack.pop() // 从栈顶弹出
    const path = paths.pop() // 始终只有同时弹出一个节点，因此路径与之匹配

    // 如果左右子节点都没有，则返回
    if (!node.left && !node.right) {
      path += node.val // 最后一个不需要拼接 -> 了
      paths.push(path)
      continue // 继续下一个
    }

    // 如果有左右节点，则压入，这里不区分顺序
    if (node.left) {
      stack.push(node.left)
      paths.push(path)
    }
    if (node.right) {
      stack.push(node.right)
      paths.push(path)
    }
  }
  return res
}
```

### hash 表

#### 求两个数组的交集

```js
var intersection = function (nums1, nums2) {
  let map = {}
  const res = []

  nums1.forEach((num) => {
    map[num] = true
  })

  nums2.forEach((num) => {
    if (map[num]) {
      res.push(num)
    }
  })

  return res.filter((item, idx) => idx === res.indexOf(item))
}
```

#### 三数之和

```js
var threeSum = function (nums) {
  const res = []
  nums.sort((a, b) => a - b)
  let len = nums.length

  for (let i = 0; i < len; i++) {
    let left = i + 1
    let right = len - 1

    // 去重第一个
    if (i > 0 && nums[i] === nums[i - 1]) continue

    // 开始遍历左右指针
    while (left < right) {
      const sum = nums[i] + nums[left] + nums[right]

      if (sum === 0) {
        res.push([nums[i], nums[left], nums[right]])

        // 只有和等于0了，说明才开始执行下面的
        while (left < right && nums[left] === nums[left + 1]) left++
        while (left < right && nums[right] === nums[right - 1]) right--

        left++
        right--
      } else if (sum > 0) {
        right--
      } else {
        left++
      }
    }
  }

  return res
}
```

## 20231119 周日

### 回溯

#### 组合总数

> 给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。

```js
var combinationSum = function (candidates, target) {
  // 组合问题，也是使用回溯，而回溯就是回来替换多层循环

  function backtrack(path, sum, start) {
    // 满足条件，这里注意，看之前错误的提交记录
    // if (sum === target) { 这样不行，因为大于的也需要返回
    if (sum >= target) {
      sum === target && res.push(path.slice())
      return
    }

    // 目前算法可以统计出全部的，但是有重复的 [[2,2,3],[2,3,2],[3,2,2],[7]]
    // 如何去重呢？去重的话，还是需要个start索引。。。
    // for循环，每个循环都是从0开始，因为可以重复，这里的重复不是在这里配置，而是backtrack的入参3是i，从而实现的重复，如果是i+1，则就是不重复的
    // 这其实依然是一个集合，然后组合问题，此时就需要使用start索引，如果是多个集合，比如拨号键组合，就不需要索引
    for (let i = start; i < candidates.length; i++) {
      // 如果已经大于target就不再压入了
      if (sum > target) break
      path.push(candidates[i])
      sum += candidates[i]
      backtrack(path, sum, i)
      sum -= candidates[i]
      path.pop()
    }
  }

  const res = []
  backtrack([], 0, 0)
  return res
}
```

#### 全排列

```js
var permute = function (nums) {
  const res = []
  const used = new Set() // 需要将这个used放在最外层，而不是内部
  backtrack([])
  return res

  function backtrack(path) {
    if (path.length === nums.length) {
      res.push(path.slice())
      return
    }

    // 放在内部，只能去除同层上的重复，但是无法去除同一个树枝上的数据
    // const used = new Set() // 需要将这个used放在最外层，而不是内部
    // 每一次都是从0开始遍历
    for (let i = 0; i < nums.length; i++) {
      if (used.has(nums[i])) continue

      used.add(nums[i])
      path.push(nums[i])
      backtrack(path.slice())
      path.pop()
      used.delete(nums[i])
    }
  }
}
```

### 二叉树

#### 最大宽度

- 利用索引
- 层序遍历，索引

```js
function widthOfBinaryTree(root) {
  if (root === null) {
    return 0
  }

  let maxWidth = 0
  const queue = [{ node: root, index: 0 }]

  while (queue.length > 0) {
    const levelSize = queue.length
    let leftmostIndex = queue[0].index
    const currentWidth = queue[queue.length - 1].index - leftmostIndex + 1
    maxWidth = Math.max(maxWidth, currentWidth)

    for (let i = 0; i < levelSize; i++) {
      const { node, index } = queue.shift()

      if (node.left) {
        queue.push({ node: node.left, index: 2 * index })
      }

      if (node.right) {
        queue.push({ node: node.right, index: 2 * index + 1 })
      }
    }
  }

  return maxWidth
}
```

#### 最小深度

```js
var minDepth = function (root) {
  // 最小深度
  if (!root) return 0
  const queue = [root]

  let minHeight = 0

  while (queue.length) {
    const len = queue.length
    minHeight++

    for (let i = 0; i < len; i++) {
      const node = queue.shift()
      // 层序遍历，队列，如果左右节点都没有值，则就是最小
      if (!node.left && !node.right) {
        return minHeight
      }
      node.left && queue.push(node.left)
      node.right && queue.push(node.right)
    }
  }
  return minHeight
}
```

#### 最大深度

```js
var maxDepth = function (root) {
  if (!root) return 0
  const queue = [root]

  let height = 0
  while (queue.length) {
    const len = queue.length
    height++

    // 这里面的循环有必要，因为len是之前记录的一层的长度，是不变的
    for (let i = 0; i < len; i++) {
      const node = queue.shift()
      node.left && queue.push(node.left)
      node.right && queue.push(node.right)
    }
  }
  return height
}
```

#### 翻转二叉树

```js
var invertTree = function (root) {
  if (!root) return root
  const queue = [root]

  while (queue.length) {
    const node = queue.shift()
    // 左右子节点交换即可，然后继续插入字节点
    ;[node.left, node.right] = [node.right, node.left]

    node.left && queue.push(node.left)
    node.right && queue.push(node.right)
  }
  return root
}
```

#### 层序遍历

```js
var levelOrder = function (root) {
  const res = []
  const queue = []

  root && queue.push(root)

  while (queue.length) {
    const len = queue.length // 当前层的数量
    const curLevel = []

    // 遍历
    for (let i = 0; i < len; i++) {
      const node = queue.shift() // 弹出队列最前面的
      curLevel.push(node.val)
      // 将当前节点的子节点放在队列里
      node.left && queue.push(node.left)
      node.right && queue.push(node.right)
    }
    // 一个for循环结束，表示一层已经遍历完，需要一层一层的返回
    res.push(curLevel)
  }

  return res
}
```

#### 中序遍历

```js
var inorderTraversal = (root) => {
  const res = [] // 结果
  const stack = [] // 二叉树遍历，利用深度优先

  root && stack.push(root) // stack = [root] 也行，就是需要let声明

  while (stack.length) {
    // 1/其实就是使用栈来遍历整个二叉树
    const node = stack.pop()

    // 3、开始处理之前放在里面的数据
    // 其实此时
    // console.log(stack)
    if (!node) {
      res.push(stack.pop().val)
      continue
    }

    // 2、将遍历的所有节点都放在栈里
    // 中序：左中右 -》右中左
    node.right && stack.push(node.right)
    stack.push(node)
    stack.push(null)
    node.left && stack.push(node.left)
  }

  return res
}
```

### hash 表

#### 三数之和

```js
var threeSum = function (nums) {
  nums.sort((a, b) => a - b)

  // 这里也可以返回，排序后，如果第一个都大于0，则直接返回，不能直接 nums[0] 因为有可能有负值
  if (nums[0] > 0) return []

  const len = nums.length
  const res = []

  for (let i = 0; i < len; i++) {
    let left = i + 1
    let right = len - 1

    // 如果不对第一个数去重，则会出现  [[-1,-1,2],[-1,0,1],[-1,0,1]] 情况
    if (nums[i] === nums[i - 1]) continue

    // 一个i，就需要对应一次 left，right的循环
    while (left < right) {
      const sum = nums[i] + nums[left] + nums[right]

      if (sum == 0) {
        res.push([nums[i], nums[left], nums[right]])

        // 去重，与下面b位置无关，left++只是走到了下一个重复的位置而已
        // 要不停的去重，而不是只去重一次，不能使用if，而应该使用while
        while (left < right && nums[left] === nums[left + 1]) left++
        while (left < right && nums[right] === nums[right - 1]) right--

        // b：当前找到一个了，那就得继续往下走
        left++
        right--
      } else if (sum > 0) {
        right--
      } else {
        left++
      }
    }
  }

  return res
}
```

### 链表

#### 合并链表

```js
var mergeTwoLists = function (list1, list2) {
  let res = new ListNode(-1)
  let p = res // p指针是移动的，
  let p1 = list1
  let p2 = list2

  // 如果两个指针都有值，则对比
  while (p1 && p2) {
    if (p1.val > p2.val) {
      // 将小值赋值，同时向下移动指针
      // 注意赋值的是下一个
      // p = p2
      p.next = p2
      p2 = p2.next
    } else {
      p.next = p1
      p1 = p1.next
    }
    // 最后移动p指针
    p = p.next
  }

  // 上面循环完以后，将剩余的链表继续挂上去，挂上去使用的p.next，而不是p = p1
  // 因为 p = p1 相当于指针移动到p1
  p1 && (p.next = p1)
  p2 && (p.next = p2)

  // 此时p位于新建链表的中间某个位置，需要返回res.next，以为内
  return res.next
}
```

#### 链表求和

```js
var addTwoNumbers = function (l1, l2) {
  // 因为两个链表的头结点都是最小值开始，因此可以直接遍历累加
  // 因为遍历两个链表后，还需要生成一个新的链表，因此需要针对新链表定义head、tail尾
  let head = null
  let tail = null
  let carry = 0 // 进位

  while (l1 || l2) {
    // 取两个链表的值
    const n1 = l1 ? l1.val : 0
    const n2 = l2 ? l2.val : 0
    const sum = n1 + n2 + carry

    if (!head) {
      // 如果没有头结点，则需要新建节点
      head = new ListNode(sum % 10)
      tail = head
    } else {
      // 此时已经有链表了，则需要追加，每追加一个，都需要新建节点
      tail.next = new ListNode(sum % 10)
      // 移动tail指针
      tail = tail.next
    }
    carry = Math.floor(sum / 10)

    // 移动两个链表的指针
    l1 && (l1 = l1.next)
    l2 && (l2 = l2.next)
  }
  // 循环结束，再判断进位即可
  carry && (tail.next = new ListNode(carry))

  return head
}
```

#### 环形链表 II

```js
var detectCycle = function (head) {
  const hasCircle = (head) => {
    let fast = (slow = head)

    while (fast && fast.next) {
      fast = fast.next.next
      slow = slow.next
      if (fast === slow) {
        mixed = slow
        return true
      }
    }
    return false
  }

  let mixed = null
  let start = head

  if (!hasCircle(head)) {
    return null
  } else {
    // 如果二者不等，则一直循环
    while (mixed !== start) {
      start = start.next
      mixed = mixed.next
    }
    return mixed
  }
}
```

#### 删除链表中倒数第 n 个节点

```js
var removeNthFromEnd = function (head, n) {
  let newHead = new ListNode(0, head)

  // 虚拟头节点
  let fast = newHead
  let slow = newHead

  // 快指针先走n步，这里需要等于n
  for (let i = 0; i <= n; i++) {
    fast = fast.next
  }

  // 然后快慢指针一块走
  while (fast) {
    fast = fast.next
    slow = slow.next
  }

  slow.next = slow.next.next

  return newHead.next
}
```

#### 翻转链表

```js
var reverseList = function (head) {
  let prev = null
  let cur = head
  // 1 -> 2 -> 3
  while (cur) {
    // 比如 cur为1， 则暂存 2
    const temp = cur.next
    cur.next = prev // 上面都存起来了，所以这里直接操作

    // 继续移动prev
    // 想象下：prev cur next 三者的关系，因此如果想继续进行，则需要左移
    prev = cur
    cur = temp
  }
  return prev
}
```

#### 移除链表中等于某个值的节点

```js
var removeElements = function (head, val) {
  // 头结点也可能等于 val，因此需要统一手法，因为删除头结点的操作不方便
  let virtual = new ListNode(0, head)

  let temp = virtual // 游走指针

  while (temp.next) {
    if (temp.next.val === val) {
      temp.next = temp.next.next
    } else {
      temp = temp.next
    }
  }
  return virtual.next
}
```

### 数组

#### [27]移除元素

> 给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。

```js
var removeElement = function (nums, val) {
  // 利用两个指针
  // 一个指针存储有效的值，一个指针在前面走
  let left = 0
  for (let i = 0; i < nums.length; i++) {
    if (nums[i] !== val) {
      nums[left++] = nums[i]
    }
  }
  // 因为只要求新长度，left就是，其实后面还有冗余的
  return left
}
```

#### [35]插入位置

```js
var searchInsert = function (nums, target) {
  let left = 0
  let right = nums.length - 1

  while (left <= right) {
    const mid = parseInt((left + right) / 2)
    // 比查找某个数字在数组的位置，要多一些逻辑
    if (nums[mid] === target) {
      return mid
    } else if (nums[mid] > target) {
      // 当大于目标值时，理论上right - 1，但此时要找插入的位置，因此就是mid
      right = mid - 1
    } else {
      // 此时target大于中位数的值，左侧一半都没有用
      left = mid + 1
    }
  }
  // 如果不在数组中，则如此：nums[pos-1]<target<num[pos]
  // 也就是 right + 1
  return right + 1
}
```

#### [704]二分查找

> 给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。

```js
var search = function (nums, target) {
  let left = 0
  let right = nums.length - 1

  // 这里需要 小于等于
  while (left <= right) {
    const mid = parseInt((left + right) / 2)

    if (nums[mid] === target) {
      return mid
    } else if (nums[mid] > target) {
      right = mid - 1
    } else {
      left = mid + 1
    }
  }
  return -1
}
```

#### 买卖股票的最佳时机

```js
var maxProfit = function (prices) {
  // 假如第 0 天买入，第 3 天卖出，那么利润为：prices[3] - prices[0]。

  // 相当于(prices[3] - prices[2]) + (prices[2] - prices[1]) + (prices[1] - prices[0])。

  // 此时就是把利润分解为每天为单位的维度，而不是从 0 天到第 3 天整体去考虑！

  // 那么根据 prices 可以得到每天的利润序列：(prices[i] - prices[i - 1]).....(prices[1] - prices[0])。

  // 因此，只需要统计正数即可
  let res = 0

  for (let i = 1; i < prices.length; i++) {
    const val = prices[i] - prices[i - 1]
    if (val > 0) {
      res += val
    }
  }
  return res
}
```

#### 合并两个有序数组

```js
var merge = function (nums1, m, nums2, n) {
  let len1 = m - 1 // 两个数组有序的最后一个值
  let len2 = n - 1
  let len = m + n - 1 // 最终数组的长度

  // 其实就是两个数组比较，然后将比较的新值放在最后
  while (len1 >= 0 && len2 >= 0) {
    nums1[len--] = nums1[len1] > nums2[len2] ? nums1[len1--] : nums2[len2--]
  }
  // 一遍循环完，要么剩余 nums2没插入进去，此时m已经遍历完了，也就是一定到索引0的位置了，因此从0开始
  // 要么就是nums2插入完了，执行下面的也无所谓
  nums1.splice(0, len2 + 1, ...nums2.slice(0, len2 + 1))
  return nums1
}
```

### 字符串

#### [344]翻转字符串

```js
var reverseString = function (s) {
  let len = s.length

  let left = 0
  let right = len - 1

  while (left <= right) {
    ;[s[left], s[right]] = [s[right], s[left]]
    left++
    right--
  }
  return s
}
```

#### [1047]删除字符串中相邻的字符

```js
var removeDuplicates = function (s) {
  const stack = []
  for (const char of s) {
    // 每次对比一个，如果相同就弹出，这里不需要while循环
    if (stack[stack.length - 1] === char) {
      stack.pop()
    } else {
      stack.push(char)
    }
  }
  return stack.join('')
}
```

#### [3]无重复的最长子串

```js
var lengthOfLongestSubstring = function (s) {
  let max = 0
  let str = ''

  for (let i = 0; i < s.length; i++) {
    const idx = str.indexOf(s[i])
    // 如果重复了，就从下一位开始截取
    // dvdy -》dv -> dv d idx 为0，需要从v开始截取
    if (idx !== -1) {
      str = str.slice(idx + 1)
    }
    str += s[i]
    max = Math.max(str.length, max)
  }
  return max
}

// 用指针，用指针的话，就可以避免上面i一直在执行的问题
var lengthOfLongestSubstring = function (s) {
  let right = 0
  let max = 0
  let str = ''

  // 这里还不能 = s.length，因为索引就到length
  while (right < s.length) {
    if (str.indexOf(s[right]) === -1) {
      str += s[right]
      right++
      max = Math.max(max, str.length)
    } else {
      // 同时字符串，还需要去掉第一个，因为必定是第一个开始相同
      str = str.slice(1)
    }
  }
  return max
}
```

### 常规算法

#### promiseLimit

```js
const promiseLimit = (ps, limit) => {
  // 异步编程，肯定需要promise
  return new Promise((resolve, reject) => {
    let running = 0
    let idx = 0
    let results = []

    // runTask 辅助函数：执行具体的异步任务
    const runTask = (task) => {
      running++
      console.log('运行中的数量：', running)
      // task本身是promise，所以直接then
      task()
        .then((res) => {
          // 到这里一个任务就结束了
          running--
          results.push(res)
          // 然后开启新的任务
          walk()
        })
        .catch((err) => reject(err))
    }

    // 主函数，执行入口
    const walk = () => {
      // 正在运行的数量小于limit，则持续压入
      while (running < limit && idx < ps.length) {
        runTask(ps[idx])
        idx++
      }
      // while循环结束后，如果running为0，说明已经全部结束
      if (!running) resolve(results)
    }
    walk()
  })
}

const tasks = [
  () => new Promise((resolve) => setTimeout(() => resolve(1), 1000)),
  () => new Promise((resolve) => setTimeout(() => resolve(2), 2000)),
  () => new Promise((resolve) => setTimeout(() => resolve(3), 3000)),
  () => new Promise((resolve) => setTimeout(() => resolve(4), 4000)),
  () => new Promise((resolve) => setTimeout(() => resolve(5), 5000)),
  () => new Promise((resolve) => setTimeout(() => resolve(6), 6000)),
]

promiseLimit(tasks, 2)
  .then((results) => {
    console.log(results)
  })
  .catch((error) => {
    console.error(error)
  })
```

#### 继承

##### 1、 原型链继承

父类的实例，作为子类的原型对象

```js
function Parent() {
  this.name = 'parent'
}
Parent.prototype.sayHi = function () {
  console.log('hi')
}

function Child() {
  this.name = 'child'
  this.age = 12
}

Child.prototype = new Parent()

var child = new Child()

console.log(child.name, child.age) // parent 12
child.sayHi() // hi

child.name = 'child'
console.log(child.name) // child
console.log(new Parent().name) // child

// 包含引用类型值的原型属性会被所有实例共享
function SuperType() {
  this.colors = ['red', 'blue', 'green']
}

function SubType() {}

//inherit from SuperType
SubType.prototype = new SuperType()

var instance1 = new SubType()

instance1.colors.push('black')
console.log(instance1.colors) //"red,blue,green,black"

var instance2 = new SubType()
console.log(instance2.colors) //"red,blue,green,black"
```

特点：

- 父类引用类型，会被子类实例继承，容易造成修改的相互影响
- 没办法传参数

##### 2、 借用构造函数继承

```js
function Parent() {
  this.arr = [1, 2, 3]
}
function Child() {
  Parent.call(this)
}

var child1 = new Child()
child1.arr.push('4')
console.log(child1.arr) // [1,2,3,4]

var child2 = new Child()
console.log(child2.arr) // [1,2,3]
```

上面的代码，引用类型，不会再在所有实例间共享了

那参数呢？

```js
function Parent(name = 'parent default') {
  this.name = name
}
function Child(name) {
  Parent.call(this, name)
  this.age = 18
}

var child1 = new Child()
console.log(child1.name) // parent default

var child2 = new Child('son')
console.log(child2.name) // son
```

##### 3、组合继承

将**原型链继承和借用构造函数继承**，组合到一块

```js
function Parent(name) {
  this.name = name
  this.arr = [1, 2, 3]
}
Parent.prototype.sayName = function () {
  console.log(this.name)
}

function Child(name, age) {
  Parent.call(this, name)
  this.age = age
}
Child.prototype = new Parent()
Child.prototype.sayAge = function () {
  console.log(this.age)
}

var c1 = new Child('c1', 20)
c1.arr.push(4)

console.log(c1.arr) // [1,2,3,4]
c1.sayAge() // 20
c1.sayName() // c1

var c2 = new Child('c2', 22)

console.log(c2.arr) // [1,2,3,4]
c2.sayAge() // 22
c2.sayName() // c2
```

##### 4、原型式继承

通过创建一个临时的中间对象， 将该对象作为新创建对象的原型，实现继承

- 定义一个空函数 F，设置 F.prototype = obj，然后返回 new F()

```js
function createObj(obj) {
  function F() {}
  // 和原型链式相比，这里直接使用的obj，而不是 新实例
  F.prototype = obj
  return new F()
}
var person = {
  name: 'p1',
  friends: [1, 2, 3],
}
var p1 = createObj(person)
console.log(p1.name) // p1
p1.friends.push(4)
console.log(p1.friends) // [1,2,3,4]

var p2 = createObj(person)
console.log(p2.name) // p1
console.log(p2.friends) // [1,2,3,4]
```

##### 5、寄生式继承

其实就是使用 Object.create 创建一个对象，然后再操作对象，可以理解为寄生在 Object.create 里

```js
function createObj(proto) {
  var obj = Object.create(proto)
  // 为对象添加函数，会由于不能做到函数复用而降低效率
  obj.greet = function () {
    console.log('hello')
  }
  return obj
}
var parent = {
  name: 'Parent',
  sayHello: function () {
    console.log('Hello')
  },
}

var child = createObj(parent)
console.log(child.name) // 输出：'Parent'
```

##### 6、组合式继承

组合式是：借用构造函数式 + 寄生式

```js
function Parent(name) {
  this.name = name
}

Parent.prototype.sayHello = function () {
  console.log('Hello, I am ' + this.name)
}

function Child(name, age) {
  Parent.call(this, name)
  this.age = age
}

Child.prototype = Object.create(Parent.prototype)
Child.prototype.constructor = Child

Child.prototype.sayAge = function () {
  console.log('I am ' + this.age + ' years old')
}

var child = new Child('Alice', 10)
console.log(child.name) // 输出：'Alice'
child.sayHello() // 输出：'Hello, I am Alice'
child.sayAge() // 输出：'I am 10 years old'
```

##### 7、寄生组合式继承

- 其实就是 借用构造函数 + 原型式 + 寄生式

```js
function object(o) {
  function F() {}
  F.prototype = o
  return new F()
}

function inheritPrototype(subType, superType) {
  var prototype = object(superType.prototype) // 创建对象
  prototype.constructor = subType // 增强对象
  subType.prototype = prototype // 指定对象
}

function SuperType(name) {
  this.name = name
  this.colors = ['red', 'blue', 'green']
}

SuperType.prototype.sayName = function () {
  alert(this.name)
}

function SubType(name, age) {
  SuperType.call(this, name)

  this.age = age
}

inheritPrototype(SubType, SuperType)

SubType.prototype.sayAge = function () {
  alert(this.age)
}

var instance1 = new SubType('Nicholas', 29)
instance1.colors.push('black')
alert(instance1.colors) //"red,blue,green,black"
instance1.sayName() //"Nicholas";
instance1.sayAge() //29

var instance2 = new SubType('Greg', 27)
alert(instance2.colors) //"red,blue,green"
instance2.sayName() //"Greg";
instance2.sayAge() //27
```

#### bind、call、apply 实现

手动实现 apply，我们要知道 apply ，就是修改 this 指向，然后立即执行函数罢了

- 而如何修改 this 指向呢？ 对象调用就 ok，
- 注意在使用 this 时，箭头函数务必要注意

```js
// 实现apply
Function.prototype.myApply = function (ctx, args) {
  ctx = ctx || window

  const uuid = Symbol()
  ctx[uuid] = this // 这里把this，也就是后续的函数，挂载在一个属性上，类似 ctx.fn = this
  // const args = [...arguments].slice(1)[0] // apply的参数二是个数组，也可以手动截取

  // 调用 // 注意：这里函数的入参 ...args 这样写，目的是为了拉齐，原生的apply，虽然不知道原生底层如何实现
  const res = ctx[uuid](...args)
  // 删除多余属性
  delete ctx[uuid]

  // 返回结果
  return res
}

// 注意：这里函数的入参 ...arr 这样写，目的是为了拉齐，原生的apply，虽然不知道原生底层如何实现
function greet(...arr) {
  // ...arr 相当于将多个参数，放在数组arr里
  // console.log(arr) // 打印数组
  console.log('hello', this.name, arr.join(' '))
}

var obj = { name: 'test' }

console.log(greet.apply(obj, ['hi apply', 'hello'])) // hello test hi apply hello
console.log(greet.myApply(obj, ['hi myapply', 'hello'])) // hello test hi myapply hello

// 实现 call
Function.prototype.myCall = function (ctx) {
  ctx = ctx || window

  // 第一项是 ctx，第二项才是 call 的入参
  const args = [...arguments].slice(1)

  const uuid = Symbol() // 防止重复
  ctx[uuid] = this // 指向未来的函数

  const res = ctx[uuid](...args)
  delete ctx[uuid]
  return res
}

var obj = { name: 'obj' }
function greet(args) {
  console.log('hello', this.name, args.join(' '))
}

greet.myCall(obj, ['hello', 'mycall']) // hello obj hello mycall
greet.call(obj, ['hello', 'call']) // hello obj hello call

// 实现bind
Function.prototype.mybind = function (ctx) {
  ctx = ctx || window

  const uuid = Symbol()
  ctx[uuid] = this

  const args = [...arguments].slice(1)

  return function (...args1) {
    const res = ctx[uuid](...args1, ...args)
    delete ctx[uuid]
    return res
  }
}

var obj = { name: 'bind' }

function greet(...args) {
  console.log('hi', this.name, args.join(' '))
}

var myGreet = greet.bind(obj, 'outer', 'haha')
myGreet()

var myGreet1 = greet.mybind(obj, 'outer', 'haha')
myGreet1()
```

#### 深拷贝

- 思路，其实就是遍历对象，然后递归拷贝
- 需要处理特殊数据类型

```js
const originalObj1 = {
  name: 'John',
  age: 30,
  address: {
    city: 'New York',
    country: 'USA',
  },
  nu: null,
  undf: undefined,
  reg: /\d/g,
  arr: [1, 2],
  fn: () => console.log('fn'),
  date: new Date(),
  symbol: Symbol(), // 不是构造函数，不能用 new
}

const deepClone = (target) => {
  const wMap = new WeakMap()

  const isType = (v) => Object.prototype.toString.call(v).slice(8, -1)
  // 需要递归
  const _deep = (obj) => {
    // 时间类型
    if (isType(obj) === 'Date') {
      return new Date(obj)
    }
    // 如果不是数组或者对象，直接返回
    if (!['Array', 'Object'].includes(isType(obj))) {
      return obj
    }

    // 如果是对象，则开始处理对象
    const res = Array.isArray(obj) ? [] : Object.create(null)

    // 已对象本身作为key，然后res作为val，防止循环引用
    if (wMap.has(obj)) {
      return wMap.get(obj)
    }
    wMap.set(obj, res) // 否则就存入map

    // 遍历对象，递归拷贝
    Object.keys(obj).forEach((key) => {
      if (res[key]) return // 如果已经复制，直接返回
      res[key] = _deep(obj[key]) // 递归拷贝
    })

    // 最后返回
    return res
  }

  return _deep(target)
}

const originalObj2 = deepClone(originalObj1)

console.log(originalObj2.address === originalObj1.address) // false
```

#### 节流

思路：

- 如果立即执行的话，不需要像防抖那样用 flag
- 如果没有剩余时间，则立即执行，同时清空 timer
- 如果有剩余时间，且没有定时器，则新建定时器

```js
const throttle = (fn, duration = 300) => {
  let timer = null
  let lastTime = 0

  return function (...args) {
    let currentTime = Date.now()
    let restTime = duration - (currentTime - lastTime)

    // 如果没有剩余时间，则立即执行，同时清除定时器
    if (restTime <= 0) {
      clearTimeout(timer) // 可以防止定时器泄露
      timer = null
      fn.apply(this, args)
      lastTime = currentTime // lastTime是上次执行的时间，因此这里这样赋值
    } else if (!timer) {
      timer = setTimeout(() => {
        fn.apply(this, args)
        timer = null
        lastTime = Date.now()
      }, restTime)
    }
  }
}

window.addEventListener(
  'resize',
  throttleImmediate(() => {
    console.log('节流')
  }, 1000)
)
```

#### 防抖

思路：

1. 返回函数
2. 再次触发，清空定时器，并延迟

```js
// 简单的
function debounce(fn, interval = 300) {
  let timer = null
  return () => {
    clearTimeout(timer)
    timer = setTimeout(fn, interval)
  }
}
const fun = () => console.log(1111)
window.addEventListener(
  'resize',
  debounce(() => console.log(1111), 1000)
)
window.addEventListener('resize', debounce(fun, 1000))
```

上面的只是普通的防抖，还可以立即执行

```js
// 带立即执行的
function debounceImmediate(fn, interval = 300, immediate = true) {
  let timer = null
  return () => {
    clearTimeout(timer)
    if (immediate) {
      // 如果立即执行，则清除定时器，并执行
      immediate = false
      fn.apply(null)
    } else {
      timer = setTimeout(() => {
        fn.apply(null)
        immediate = true
      }, interval)
    }
  }
}

const fun2 = () => console.log(2222)
window.addEventListener('resize', debounceImmediate(fun2, 1000))
```
