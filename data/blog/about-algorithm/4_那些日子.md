---
title: 那些日子
date: Sun Nov 19 2023 16:06:28 GMT+0800 (中国标准时间)
lastmod: 2023/11/19
tags: [day, 巩固]
draft: false
summary: 要想看起来毫不费力,就需要背后用尽全力
layout: PostSimple
bibliography: references-data.bib
canonicalUrl: https://dume.vercel.app/blog/about-algorithm/4_那些日子.md
---

## 20231119 周日

### 回溯

#### 组合总数

> 给你一个 无重复元素 的整数数组 candidates 和一个目标整数 target ，找出 candidates 中可以使数字和为目标数 target 的 所有 不同组合 ，并以列表形式返回。你可以按 任意顺序 返回这些组合。

```js
var combinationSum = function (candidates, target) {
  // 组合问题，也是使用回溯，而回溯就是回来替换多层循环

  function backtrack(path, sum, start) {
    // 满足条件，这里注意，看之前错误的提交记录
    // if (sum === target) { 这样不行，因为大于的也需要返回
    if (sum >= target) {
      sum === target && res.push(path.slice())
      return
    }

    // 目前算法可以统计出全部的，但是有重复的 [[2,2,3],[2,3,2],[3,2,2],[7]]
    // 如何去重呢？去重的话，还是需要个start索引。。。
    // for循环，每个循环都是从0开始，因为可以重复，这里的重复不是在这里配置，而是backtrack的入参3是i，从而实现的重复，如果是i+1，则就是不重复的
    // 这其实依然是一个集合，然后组合问题，此时就需要使用start索引，如果是多个集合，比如拨号键组合，就不需要索引
    for (let i = start; i < candidates.length; i++) {
      // 如果已经大于target就不再压入了
      if (sum > target) break
      path.push(candidates[i])
      sum += candidates[i]
      backtrack(path, sum, i)
      sum -= candidates[i]
      path.pop()
    }
  }

  const res = []
  backtrack([], 0, 0)
  return res
}
```

#### 全排列

```js
var permute = function (nums) {
  const res = []
  const used = new Set() // 需要将这个used放在最外层，而不是内部
  backtrack([])
  return res

  function backtrack(path) {
    if (path.length === nums.length) {
      res.push(path.slice())
      return
    }

    // 放在内部，只能去除同层上的重复，但是无法去除同一个树枝上的数据
    // const used = new Set() // 需要将这个used放在最外层，而不是内部

    // 每一次都是从0开始遍历
    for (let i = 0; i < nums.length; i++) {
      if (used.has(nums[i])) continue

      used.add(nums[i])
      path.push(nums[i])
      backtrack(path.slice())
      path.pop()
      used.delete(nums[i])
    }
  }
}
```

### 二叉树

#### 最大宽度

- 利用索引
- 层序遍历，索引

```js
function widthOfBinaryTree(root) {
  if (root === null) {
    return 0
  }

  let maxWidth = 0
  const queue = [{ node: root, index: 0 }]

  while (queue.length > 0) {
    const levelSize = queue.length
    let leftmostIndex = queue[0].index
    const currentWidth = queue[queue.length - 1].index - leftmostIndex + 1
    maxWidth = Math.max(maxWidth, currentWidth)

    for (let i = 0; i < levelSize; i++) {
      const { node, index } = queue.shift()

      if (node.left) {
        queue.push({ node: node.left, index: 2 * index })
      }

      if (node.right) {
        queue.push({ node: node.right, index: 2 * index + 1 })
      }
    }
  }

  return maxWidth
}
```

#### 最小深度

```js
var minDepth = function (root) {
  // 最小深度
  if (!root) return 0
  const queue = [root]

  let minHeight = 0

  while (queue.length) {
    const len = queue.length
    minHeight++

    for (let i = 0; i < len; i++) {
      const node = queue.shift()
      // 层序遍历，队列，如果左右节点都没有值，则就是最小
      if (!node.left && !node.right) {
        return minHeight
      }
      node.left && queue.push(node.left)
      node.right && queue.push(node.right)
    }
  }
  return minHeight
}
```

#### 最大深度

```js
var maxDepth = function (root) {
  if (!root) return 0
  const queue = [root]

  let height = 0
  while (queue.length) {
    const len = queue.length
    height++

    // 这里面的循环有必要，因为len是之前记录的一层的长度，是不变的
    for (let i = 0; i < len; i++) {
      const node = queue.shift()
      node.left && queue.push(node.left)
      node.right && queue.push(node.right)
    }
  }
  return height
}
```

#### 翻转二叉树

```js
var invertTree = function (root) {
  if (!root) return root
  const queue = [root]

  while (queue.length) {
    const node = queue.shift()
    // 左右子节点交换即可，然后继续插入字节点
    ;[node.left, node.right] = [node.right, node.left]

    node.left && queue.push(node.left)
    node.right && queue.push(node.right)
  }
  return root
}
```

#### 层序遍历

```js
var levelOrder = function (root) {
  const res = []
  const queue = []

  root && queue.push(root)

  while (queue.length) {
    const len = queue.length // 当前层的数量
    const curLevel = []

    // 遍历
    for (let i = 0; i < len; i++) {
      const node = queue.shift() // 弹出队列最前面的
      curLevel.push(node.val)
      // 将当前节点的子节点放在队列里
      node.left && queue.push(node.left)
      node.right && queue.push(node.right)
    }
    // 一个for循环结束，表示一层已经遍历完，需要一层一层的返回
    res.push(curLevel)
  }

  return res
}
```

#### 中序遍历

```js
var inorderTraversal = (root) => {
  const res = [] // 结果
  const stack = [] // 二叉树遍历，利用深度优先

  root && stack.push(root) // stack = [root] 也行，就是需要let声明

  while (stack.length) {
    // 1/其实就是使用栈来遍历整个二叉树
    const node = stack.pop()

    // 3、开始处理之前放在里面的数据
    // 其实此时
    // console.log(stack)
    if (!node) {
      res.push(stack.pop().val)
      continue
    }

    // 2、将遍历的所有节点都放在栈里
    // 中序：左中右 -》右中左
    node.right && stack.push(node.right)
    stack.push(node)
    stack.push(null)
    node.left && stack.push(node.left)
  }

  return res
}
```

### hash 表

#### 三数之和

```js
var threeSum = function (nums) {
  nums.sort((a, b) => a - b)

  // 这里也可以返回，排序后，如果第一个都大于0，则直接返回，不能直接 nums[0] 因为有可能有负值
  if (nums[0] > 0) return []

  const len = nums.length
  const res = []

  for (let i = 0; i < len; i++) {
    let left = i + 1
    let right = len - 1

    // 如果不对第一个数去重，则会出现  [[-1,-1,2],[-1,0,1],[-1,0,1]] 情况
    if (nums[i] === nums[i - 1]) continue

    // 一个i，就需要对应一次 left，right的循环
    while (left < right) {
      const sum = nums[i] + nums[left] + nums[right]

      if (sum == 0) {
        res.push([nums[i], nums[left], nums[right]])

        // 去重，与下面b位置无关，left++只是走到了下一个重复的位置而已
        // 要不停的去重，而不是只去重一次，不能使用if，而应该使用while
        while (left < right && nums[left] === nums[left + 1]) left++
        while (left < right && nums[right] === nums[right - 1]) right--

        // b：当前找到一个了，那就得继续往下走
        left++
        right--
      } else if (sum > 0) {
        right--
      } else {
        left++
      }
    }
  }

  return res
}
```

### 链表

#### 合并链表

```js
var mergeTwoLists = function (list1, list2) {
  let res = new ListNode(-1)
  let p = res // p指针是移动的，
  let p1 = list1
  let p2 = list2

  // 如果两个指针都有值，则对比
  while (p1 && p2) {
    if (p1.val > p2.val) {
      // 将小值赋值，同时向下移动指针
      // 注意赋值的是下一个
      // p = p2
      p.next = p2
      p2 = p2.next
    } else {
      p.next = p1
      p1 = p1.next
    }
    // 最后移动p指针
    p = p.next
  }

  // 上面循环完以后，将剩余的链表继续挂上去，挂上去使用的p.next，而不是p = p1
  // 因为 p = p1 相当于指针移动到p1
  p1 && (p.next = p1)
  p2 && (p.next = p2)

  // 此时p位于新建链表的中间某个位置，需要返回res.next，以为内
  return res.next
}
```

#### 链表求和

```js
var addTwoNumbers = function (l1, l2) {
  // 因为两个链表的头结点都是最小值开始，因此可以直接遍历累加
  // 因为遍历两个链表后，还需要生成一个新的链表，因此需要针对新链表定义head、tail尾
  let head = null
  let tail = null
  let carry = 0 // 进位

  while (l1 || l2) {
    // 取两个链表的值
    const n1 = l1 ? l1.val : 0
    const n2 = l2 ? l2.val : 0
    const sum = n1 + n2 + carry

    if (!head) {
      // 如果没有头结点，则需要新建节点
      head = new ListNode(sum % 10)
      tail = head
    } else {
      // 此时已经有链表了，则需要追加，每追加一个，都需要新建节点
      tail.next = new ListNode(sum % 10)
      // 移动tail指针
      tail = tail.next
    }
    carry = Math.floor(sum / 10)

    // 移动两个链表的指针
    l1 && (l1 = l1.next)
    l2 && (l2 = l2.next)
  }
  // 循环结束，再判断进位即可
  carry && (tail.next = new ListNode(carry))

  return head
}
```

#### 环形链表 II

```js
var detectCycle = function (head) {
  const hasCircle = (head) => {
    let fast = (slow = head)

    while (fast && fast.next) {
      fast = fast.next.next
      slow = slow.next
      if (fast === slow) {
        mixed = slow
        return true
      }
    }
    return false
  }

  let mixed = null
  let start = head

  if (!hasCircle(head)) {
    return null
  } else {
    // 如果二者不等，则一直循环
    while (mixed !== start) {
      start = start.next
      mixed = mixed.next
    }
    return mixed
  }
}
```

#### 删除链表中倒数第 n 个节点

```js
var removeNthFromEnd = function (head, n) {
  let newHead = new ListNode(0, head)

  // 虚拟头节点
  let fast = newHead
  let slow = newHead

  // 快指针先走n步，这里需要等于n
  for (let i = 0; i <= n; i++) {
    fast = fast.next
  }

  // 然后快慢指针一块走
  while (fast) {
    fast = fast.next
    slow = slow.next
  }

  slow.next = slow.next.next

  return newHead.next
}
```

#### 翻转链表

```js
var reverseList = function (head) {
  let prev = null
  let cur = head
  // 1 -> 2 -> 3
  while (cur) {
    // 比如 cur为1， 则暂存 2
    const temp = cur.next
    cur.next = prev // 上面都存起来了，所以这里直接操作

    // 继续移动prev
    // 想象下：prev cur next 三者的关系，因此如果想继续进行，则需要左移
    prev = cur
    cur = temp
  }
  return prev
}
```

#### 移除链表中等于某个值的节点

```js
var removeElements = function (head, val) {
  // 头结点也可能等于 val，因此需要统一手法，因为删除头结点的操作不方便
  let virtual = new ListNode(0, head)

  let temp = virtual // 游走指针

  while (temp.next) {
    if (temp.next.val === val) {
      temp.next = temp.next.next
    } else {
      temp = temp.next
    }
  }
  return virtual.next
}
```

### 数组

#### [27]移除元素

> 给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。

```js
var removeElement = function (nums, val) {
  // 利用两个指针
  // 一个指针存储有效的值，一个指针在前面走
  let left = 0
  for (let i = 0; i < nums.length; i++) {
    if (nums[i] !== val) {
      nums[left++] = nums[i]
    }
  }
  // 因为只要求新长度，left就是，其实后面还有冗余的
  return left
}
```

#### [35]插入位置

```js
var searchInsert = function (nums, target) {
  let left = 0
  let right = nums.length - 1

  while (left <= right) {
    const mid = parseInt((left + right) / 2)
    // 比查找某个数字在数组的位置，要多一些逻辑
    if (nums[mid] === target) {
      return mid
    } else if (nums[mid] > target) {
      // 当大于目标值时，理论上right - 1，但此时要找插入的位置，因此就是mid
      right = mid - 1
    } else {
      // 此时target大于中位数的值，左侧一半都没有用
      left = mid + 1
    }
  }
  // 如果不在数组中，则如此：nums[pos-1]<target<num[pos]
  // 也就是 right + 1
  return right + 1
}
```

#### [704]二分查找

> 给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。

```js
var search = function (nums, target) {
  let left = 0
  let right = nums.length - 1

  // 这里需要 小于等于
  while (left <= right) {
    const mid = parseInt((left + right) / 2)

    if (nums[mid] === target) {
      return mid
    } else if (nums[mid] > target) {
      right = mid - 1
    } else {
      left = mid + 1
    }
  }
  return -1
}
```

#### 买卖股票的最佳时机

```js
var maxProfit = function (prices) {
  // 假如第 0 天买入，第 3 天卖出，那么利润为：prices[3] - prices[0]。

  // 相当于(prices[3] - prices[2]) + (prices[2] - prices[1]) + (prices[1] - prices[0])。

  // 此时就是把利润分解为每天为单位的维度，而不是从 0 天到第 3 天整体去考虑！

  // 那么根据 prices 可以得到每天的利润序列：(prices[i] - prices[i - 1]).....(prices[1] - prices[0])。

  // 因此，只需要统计正数即可
  let res = 0

  for (let i = 1; i < prices.length; i++) {
    const val = prices[i] - prices[i - 1]
    if (val > 0) {
      res += val
    }
  }
  return res
}
```

#### 合并两个有序数组

```js
var merge = function (nums1, m, nums2, n) {
  let len1 = m - 1 // 两个数组有序的最后一个值
  let len2 = n - 1
  let len = m + n - 1 // 最终数组的长度

  // 其实就是两个数组比较，然后将比较的新值放在最后
  while (len1 >= 0 && len2 >= 0) {
    nums1[len--] = nums1[len1] > nums2[len2] ? nums1[len1--] : nums2[len2--]
  }
  // 一遍循环完，要么剩余 nums2没插入进去，此时m已经遍历完了，也就是一定到索引0的位置了，因此从0开始
  // 要么就是nums2插入完了，执行下面的也无所谓
  nums1.splice(0, len2 + 1, ...nums2.slice(0, len2 + 1))
  return nums1
}
```

### 字符串

#### [344]翻转字符串

```js
var reverseString = function (s) {
  let len = s.length

  let left = 0
  let right = len - 1

  while (left <= right) {
    ;[s[left], s[right]] = [s[right], s[left]]
    left++
    right--
  }
  return s
}
```

#### [1047]删除字符串中相邻的字符

```js
var removeDuplicates = function (s) {
  const stack = []
  for (const char of s) {
    // 每次对比一个，如果相同就弹出，这里不需要while循环
    if (stack[stack.length - 1] === char) {
      stack.pop()
    } else {
      stack.push(char)
    }
  }
  return stack.join('')
}
```

#### [3]无重复的最长子串

```js
var lengthOfLongestSubstring = function (s) {
  let max = 0
  let str = ''

  for (let i = 0; i < s.length; i++) {
    const idx = str.indexOf(s[i])
    // 如果重复了，就从下一位开始截取
    // dvdy -》dv -> dv d idx 为0，需要从v开始截取
    if (idx !== -1) {
      str = str.slice(idx + 1)
    }
    str += s[i]
    max = Math.max(str.length, max)
  }
  return max
}

// 用指针，用指针的话，就可以避免上面i一直在执行的问题
var lengthOfLongestSubstring = function (s) {
  let right = 0
  let max = 0
  let str = ''

  // 这里还不能 = s.length，因为索引就到length
  while (right < s.length) {
    if (str.indexOf(s[right]) === -1) {
      str += s[right]
      right++
      max = Math.max(max, str.length)
    } else {
      // 同时字符串，还需要去掉第一个，因为必定是第一个开始相同
      str = str.slice(1)
    }
  }
  return max
}
```

### 常规算法

#### promiseLimit

```js
const promiseLimit = (ps, limit) => {
  // 异步编程，肯定需要promise
  return new Promise((resolve, reject) => {
    let running = 0
    let idx = 0
    let results = []

    // runTask 辅助函数：执行具体的异步任务
    const runTask = (task) => {
      running++
      console.log('运行中的数量：', running)
      // task本身是promise，所以直接then
      task()
        .then((res) => {
          // 到这里一个任务就结束了
          running--
          results.push(res)
          // 然后开启新的任务
          walk()
        })
        .catch((err) => reject(err))
    }

    // 主函数，执行入口
    const walk = () => {
      // 正在运行的数量小于limit，则持续压入
      while (running < limit && idx < ps.length) {
        runTask(ps[idx])
        idx++
      }
      // while循环结束后，如果running为0，说明已经全部结束
      if (!running) resolve(results)
    }
    walk()
  })
}

const tasks = [
  () => new Promise((resolve) => setTimeout(() => resolve(1), 1000)),
  () => new Promise((resolve) => setTimeout(() => resolve(2), 2000)),
  () => new Promise((resolve) => setTimeout(() => resolve(3), 3000)),
  () => new Promise((resolve) => setTimeout(() => resolve(4), 4000)),
  () => new Promise((resolve) => setTimeout(() => resolve(5), 5000)),
  () => new Promise((resolve) => setTimeout(() => resolve(6), 6000)),
]

promiseLimit(tasks, 2)
  .then((results) => {
    console.log(results)
  })
  .catch((error) => {
    console.error(error)
  })
```

#### 继承

##### 1、 原型链继承

父类的实例，作为子类的原型对象

```js
function Parent() {
  this.name = 'parent'
}
Parent.prototype.sayHi = function () {
  console.log('hi')
}

function Child() {
  this.name = 'child'
  this.age = 12
}

Child.prototype = new Parent()

var child = new Child()

console.log(child.name, child.age) // parent 12
child.sayHi() // hi

child.name = 'child'
console.log(child.name) // child
console.log(new Parent().name) // child

// 包含引用类型值的原型属性会被所有实例共享
function SuperType() {
  this.colors = ['red', 'blue', 'green']
}

function SubType() {}

//inherit from SuperType
SubType.prototype = new SuperType()

var instance1 = new SubType()

instance1.colors.push('black')
console.log(instance1.colors) //"red,blue,green,black"

var instance2 = new SubType()
console.log(instance2.colors) //"red,blue,green,black"
```

特点：

- 父类引用类型，会被子类实例继承，容易造成修改的相互影响
- 没办法传参数

##### 2、 借用构造函数继承

```js
function Parent() {
  this.arr = [1, 2, 3]
}
function Child() {
  Parent.call(this)
}

var child1 = new Child()
child1.arr.push('4')
console.log(child1.arr) // [1,2,3,4]

var child2 = new Child()
console.log(child2.arr) // [1,2,3]
```

上面的代码，引用类型，不会再在所有实例间共享了

那参数呢？

```js
function Parent(name = 'parent default') {
  this.name = name
}
function Child(name) {
  Parent.call(this, name)
  this.age = 18
}

var child1 = new Child()
console.log(child1.name) // parent default

var child2 = new Child('son')
console.log(child2.name) // son
```

##### 3、组合继承

将**原型链继承和借用构造函数继承**，组合到一块

```js
function Parent(name) {
  this.name = name
  this.arr = [1, 2, 3]
}
Parent.prototype.sayName = function () {
  console.log(this.name)
}

function Child(name, age) {
  Parent.call(this, name)
  this.age = age
}
Child.prototype = new Parent()
Child.prototype.sayAge = function () {
  console.log(this.age)
}

var c1 = new Child('c1', 20)
c1.arr.push(4)

console.log(c1.arr) // [1,2,3,4]
c1.sayAge() // 20
c1.sayName() // c1

var c2 = new Child('c2', 22)

console.log(c2.arr) // [1,2,3,4]
c2.sayAge() // 22
c2.sayName() // c2
```

##### 4、原型式继承

通过创建一个临时的中间对象， 将该对象作为新创建对象的原型，实现继承

- 定义一个空函数 F，设置 F.prototype = obj，然后返回 new F()

```js
function createObj(obj) {
  function F() {}
  // 和原型链式相比，这里直接使用的obj，而不是 新实例
  F.prototype = obj
  return new F()
}
var person = {
  name: 'p1',
  friends: [1, 2, 3],
}
var p1 = createObj(person)
console.log(p1.name) // p1
p1.friends.push(4)
console.log(p1.friends) // [1,2,3,4]

var p2 = createObj(person)
console.log(p2.name) // p1
console.log(p2.friends) // [1,2,3,4]
```

##### 5、寄生式继承

其实就是使用 Object.create 创建一个对象，然后再操作对象，可以理解为寄生在 Object.create 里

```js
function createObj(proto) {
  var obj = Object.create(proto)
  // 为对象添加函数，会由于不能做到函数复用而降低效率
  obj.greet = function () {
    console.log('hello')
  }
  return obj
}
var parent = {
  name: 'Parent',
  sayHello: function () {
    console.log('Hello')
  },
}

var child = createObj(parent)
console.log(child.name) // 输出：'Parent'
```

##### 6、组合式继承

组合式是：借用构造函数式 + 寄生式

```js
function Parent(name) {
  this.name = name
}

Parent.prototype.sayHello = function () {
  console.log('Hello, I am ' + this.name)
}

function Child(name, age) {
  Parent.call(this, name)
  this.age = age
}

Child.prototype = Object.create(Parent.prototype)
Child.prototype.constructor = Child

Child.prototype.sayAge = function () {
  console.log('I am ' + this.age + ' years old')
}

var child = new Child('Alice', 10)
console.log(child.name) // 输出：'Alice'
child.sayHello() // 输出：'Hello, I am Alice'
child.sayAge() // 输出：'I am 10 years old'
```

##### 7、寄生组合式继承

- 其实就是 借用构造函数 + 原型式 + 寄生式

```js
function object(o) {
  function F() {}
  F.prototype = o
  return new F()
}

function inheritPrototype(subType, superType) {
  var prototype = object(superType.prototype) // 创建对象
  prototype.constructor = subType // 增强对象
  subType.prototype = prototype // 指定对象
}

function SuperType(name) {
  this.name = name
  this.colors = ['red', 'blue', 'green']
}

SuperType.prototype.sayName = function () {
  alert(this.name)
}

function SubType(name, age) {
  SuperType.call(this, name)

  this.age = age
}

inheritPrototype(SubType, SuperType)

SubType.prototype.sayAge = function () {
  alert(this.age)
}

var instance1 = new SubType('Nicholas', 29)
instance1.colors.push('black')
alert(instance1.colors) //"red,blue,green,black"
instance1.sayName() //"Nicholas";
instance1.sayAge() //29

var instance2 = new SubType('Greg', 27)
alert(instance2.colors) //"red,blue,green"
instance2.sayName() //"Greg";
instance2.sayAge() //27
```

#### bind、call、apply 实现

手动实现 apply，我们要知道 apply ，就是修改 this 指向，然后立即执行函数罢了

- 而如何修改 this 指向呢？ 对象调用就 ok，
- 注意在使用 this 时，箭头函数务必要注意

```js
// 实现apply
Function.prototype.myApply = function (ctx, args) {
  ctx = ctx || window

  const uuid = Symbol()
  ctx[uuid] = this // 这里把this，也就是后续的函数，挂载在一个属性上，类似 ctx.fn = this
  // const args = [...arguments].slice(1)[0] // apply的参数二是个数组，也可以手动截取

  // 调用 // 注意：这里函数的入参 ...args 这样写，目的是为了拉齐，原生的apply，虽然不知道原生底层如何实现
  const res = ctx[uuid](...args)
  // 删除多余属性
  delete ctx[uuid]

  // 返回结果
  return res
}

// 注意：这里函数的入参 ...arr 这样写，目的是为了拉齐，原生的apply，虽然不知道原生底层如何实现
function greet(...arr) {
  // ...arr 相当于将多个参数，放在数组arr里
  // console.log(arr) // 打印数组
  console.log('hello', this.name, arr.join(' '))
}

var obj = { name: 'test' }

console.log(greet.apply(obj, ['hi apply', 'hello'])) // hello test hi apply hello
console.log(greet.myApply(obj, ['hi myapply', 'hello'])) // hello test hi myapply hello

// 实现 call
Function.prototype.myCall = function (ctx) {
  ctx = ctx || window

  // 第一项是 ctx，第二项才是 call 的入参
  const args = [...arguments].slice(1)

  const uuid = Symbol() // 防止重复
  ctx[uuid] = this // 指向未来的函数

  const res = ctx[uuid](...args)
  delete ctx[uuid]
  return res
}

var obj = { name: 'obj' }
function greet(args) {
  console.log('hello', this.name, args.join(' '))
}

greet.myCall(obj, ['hello', 'mycall']) // hello obj hello mycall
greet.call(obj, ['hello', 'call']) // hello obj hello call

// 实现bind
Function.prototype.mybind = function (ctx) {
  ctx = ctx || window

  const uuid = Symbol()
  ctx[uuid] = this

  const args = [...arguments].slice(1)

  return function (...args1) {
    const res = ctx[uuid](...args1, ...args)
    delete ctx[uuid]
    return res
  }
}

var obj = { name: 'bind' }

function greet(...args) {
  console.log('hi', this.name, args.join(' '))
}

var myGreet = greet.bind(obj, 'outer', 'haha')
myGreet()

var myGreet1 = greet.mybind(obj, 'outer', 'haha')
myGreet1()
```

#### 深拷贝

- 思路，其实就是遍历对象，然后递归拷贝
- 需要处理特殊数据类型

```js
const originalObj1 = {
  name: 'John',
  age: 30,
  address: {
    city: 'New York',
    country: 'USA',
  },
  nu: null,
  undf: undefined,
  reg: /\d/g,
  arr: [1, 2],
  fn: () => console.log('fn'),
  date: new Date(),
  symbol: Symbol(), // 不是构造函数，不能用 new
}

const deepClone = (target) => {
  const wMap = new WeakMap()

  const isType = (v) => Object.prototype.toString.call(v).slice(8, -1)
  // 需要递归
  const _deep = (obj) => {
    // 时间类型
    if (isType(obj) === 'Date') {
      return new Date(obj)
    }
    // 如果不是数组或者对象，直接返回
    if (!['Array', 'Object'].includes(isType(obj))) {
      return obj
    }

    // 如果是对象，则开始处理对象
    const res = Array.isArray(obj) ? [] : Object.create(null)

    // 已对象本身作为key，然后res作为val，防止循环引用
    if (wMap.has(obj)) {
      return wMap.get(obj)
    }
    wMap.set(obj, res) // 否则就存入map

    // 遍历对象，递归拷贝
    Object.keys(obj).forEach((key) => {
      if (res[key]) return // 如果已经复制，直接返回
      res[key] = _deep(obj[key]) // 递归拷贝
    })

    // 最后返回
    return res
  }

  return _deep(target)
}

const originalObj2 = deepClone(originalObj1)

console.log(originalObj2.address === originalObj1.address) // false
```

#### 节流

思路：

- 如果立即执行的话，不需要像防抖那样用 flag
- 如果没有剩余时间，则立即执行，同时清空 timer
- 如果有剩余时间，且没有定时器，则新建定时器

```js
const throttle = (fn, duration = 300) => {
  let timer = null
  let lastTime = 0

  return function (...args) {
    let currentTime = Date.now()
    let restTime = duration - (currentTime - lastTime)

    // 如果没有剩余时间，则立即执行，同时清除定时器
    if (restTime <= 0) {
      clearTimeout(timer) // 可以防止定时器泄露
      timer = null
      fn.apply(this, args)
      lastTime = currentTime // lastTime是上次执行的时间，因此这里这样赋值
    } else if (!timer) {
      timer = setTimeout(() => {
        fn.apply(this, args)
        timer = null
        lastTime = Date.now()
      }, restTime)
    }
  }
}

window.addEventListener(
  'resize',
  throttleImmediate(() => {
    console.log('节流')
  }, 1000)
)
```

#### 防抖

思路：

1. 返回函数
2. 再次触发，清空定时器，并延迟

```js
// 简单的
function debounce(fn, interval = 300) {
  let timer = null
  return () => {
    clearTimeout(timer)
    timer = setTimeout(fn, interval)
  }
}
const fun = () => console.log(1111)
window.addEventListener(
  'resize',
  debounce(() => console.log(1111), 1000)
)
window.addEventListener('resize', debounce(fun, 1000))
```

上面的只是普通的防抖，还可以立即执行

```js
// 带立即执行的
function debounceImmediate(fn, interval = 300, immediate = true) {
  let timer = null
  return () => {
    clearTimeout(timer)
    if (immediate) {
      // 如果立即执行，则清除定时器，并执行
      immediate = false
      fn.apply(null)
    } else {
      timer = setTimeout(() => {
        fn.apply(null)
        immediate = true
      }, interval)
    }
  }
}

const fun2 = () => console.log(2222)
window.addEventListener('resize', debounceImmediate(fun2, 1000))
```
