---
title: '算法之如何学习'
date: Thu Aug 31 2023 08:49:25 GMT+0800 (中国标准时间)
lastmod: '2023-09-31'
tags: ['数据结构', '算法']
draft: false
summary: '算法与数据结构'
layout: PostSimple
bibliography: references-data.bib
canonicalUrl: https://dume.vercel.app/blog/about-algorithm/0_算法之如何学习
---

## 算法

一个好的算法应该具备以下特征：

- 明确定义的输入和输出：算法应该清楚地定义输入数据的形式和要求，以及生成的输出结果。

- 确定性：对于给定的输入，算法应该以确定的方式执行，不会产生随机或不可预测的结果。

- 有限性：算法应该在有限的步骤内完成，不会陷入无限循环或无法终止的状态。

- 可行性：算法应该在合理的时间内完成，不会消耗过多的计算资源或时间。

- 正确性：算法应该按照预期解决问题，并产生正确的输出结果。

## 如何高质量的学习算法

学习算法是一个需要持续努力和系统性学习的过程。以下是一些建议，可以帮助您高质量地学习算法：

1. 建立扎实的基础知识: 确保您对基本的数据结构和算法有一定的了解，包括数组、链表、树、图等常见的数据结构，以及排序、搜索、递归、动态规划等基本算法的概念和实现。

2. 选择合适的学习资源: 寻找高质量的学习资源，如经典的算法教材、在线课程、教学视频、博客文章、编程竞赛平台等。确保资源内容清晰、准确，并具有良好的讲解和示例。

3. 理论与实践相结合: 算法学习不仅仅是理论，还需要实践。尝试使用编程语言实现算法，并在不同的问题上进行练习和应用。通过实际的编码实践，加深对算法的理解和应用能力。

4. 刷题与解决实际问题: 刷题是学习算法的一种有效方式，可以帮助您熟悉不同类型的算法问题，提高解决问题的能力。除了刷题，还要尝试解决实际的工程或科学问题，将学到的算法知识应用到实际场景中。

5. 参与讨论与交流: 加入算法学习社区，参与讨论和交流。与其他学习者一起分享经验、解决问题，听取他人的观点和建议。参与编程竞赛、算法比赛等活动，与其他优秀的算法学习者切磋交流，提高自己的水平。

6. 深入理解和分析: 学习算法不只是掌握表面的概念和实现，还要深入理解算法的原理和思想。尝试分析算法的时间复杂度、空间复杂度，思考算法的优化方法和边界条件。通过深入理解，可以更好地应用和优化算法。

7. 持续学习和实践: 算法学习是一个持续的过程，不要停止学习和实践的步伐。保持学习的动力和兴趣，持续挑战自己，不断扩展和深化自己的算法知识和技能。

最重要的是，学习算法需要耐心和坚持。不要被困难或挫折打击，保持积极的学习态度，相信自己的能力，坚持不懈地学习和实践，您将逐渐提高自己的算法水平。

## 学习算法网站推荐

- [labuladong 的算法小抄](https://labuladong.github.io/algo/)

## 算法性能分析

那么该如何估计程序运行时间呢，通常会估算算法的操作单元数量来代表程序消耗的时间，这里默认 CPU 的每个单元运行消耗的时间都是相同的。

算法导论给出的解释：**大 O 用来表示上界的**，当用它作为算法的最坏情况运行时间的上界，就是对任意数据输入的运行时间的上界。

都知道快速排序是 O(nlogn)，但是当数据已经有序情况下，快速排序的时间复杂度是 O(n^2) 的，**所以严格从大 O 的定义来讲，快速排序的时间复杂度应该是 O(n^2)**。

**但是我们依然说快速排序是 O(nlogn)的时间复杂度，这个就是业内的一个默认规定，这里说的 O 代表的就是一般情况，而不是严格的上界。**

那为什么在计算时间复杂度的时候要忽略常数项系数呢，也就说 O(100n) 就是 O(n)的时间复杂度，O(5n^2) 就是 O(n^2)的时间复杂度，而且要默认 O(n) 优于 O(n^2) 呢 ？

这里就又涉及到大 O 的定义，因为大 O 就是数据量级突破一个点且数据量级非常大的情况下所表现出的时间复杂度，这个数据量也就是常数项系数已经不起决定性作用的数据量。

### O(logn)中的 log 是以什么为底？

假如有两个算法的时间复杂度，分别是 log 以 2 为底 n 的对数和 log 以 10 为底 n 的对数，那么这里如果还记得高中数学的话，应该不难理解**以 2 为底 n 的对数 = 以 2 为底 10 的对数 \* 以 10 为底 n 的对数**。

而以 2 为底 10 的对数是一个常数，在上文已经讲述了我们计算时间复杂度是忽略常数项系数的。

抽象一下就是在时间复杂度的计算过程中，log 以 i 为底 n 的对数等于 log 以 j 为底 n 的对数，所以忽略了 i，直接说是 logn。

### 算法超时

- 1GHz（兆赫）= 1000MHz（兆赫）
- 1MHz（兆赫）= 1 百万赫兹

所以 1GHz = 10 亿 Hz，表示 CPU 可以一秒脉冲 10 亿次（有 10 亿个时钟周期，可以理解为一次改变状态，也叫时钟周期），这里不要简单理解一个时钟周期就是一次 CPU 运算。

例如 1 + 2 = 3，cpu 要执行四次才能完整这个操作，步骤一：把 1 放入寄存机，步骤二：把 2 放入寄存器，步骤三：做加法，步骤四：保存 3。

可以统计不同数据规模下，1s 能计算多少次？进而来断定电脑在 1s 内处理多大数量级数据

### 递归的时间复杂度

实现一个 x 的 n 次方 的算法

```js
const fn1 = (x, n) => {
  let res = 1
  for (let i = 0; i < n; i++) {
    // 第一次循环，res 就是 x，然后每次循环都会乘以 x，就实现了 多个x的 相乘运算
    res = res * x
  }
  return res
}
```

此时上面的时间复杂度是 O(n)，那有没有更高的算法？

```js
const fn2 = (x, n) => {
  if ((n = 0)) {
    return 1
  }
}
```
