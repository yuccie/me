---
title: 那些妙的算法
date: Tue Oct 31 2023 22:26:46 GMT+0800 (中国标准时间)
lastmod: 2023/10/31
tags: [算法, 记忆]
draft: false
summary: 那些妙的算法
layout: PostSimple
bibliography: references-data.bib
canonicalUrl: https://dume.vercel.app/blog/about-algorithm/3_那些妙的算法.md
---

## 数组相关

### 二分查找

#### 【704】

> 给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。

🔥 技巧 🔥：

- 二分法
- 中点取值：`parseInt((left+right)/2)` , `Math.floor((left+right)/2)`, `Math.floor((right-left)/2 + left)`

```js
var search = function (nums, target) {
  let left = 0
  let right = nums.length - 1

  while (left <= right) {
    let mid = parseInt((left + right) / 2)

    if (nums[mid] === target) {
      return mid
    } else if (nums[mid] > target) {
      right = mid - 1
    } else {
      // 小于的话，左侧的都无效
      left = mid + 1
    }
  }
  return -1
}
```

#### 搜索插入位置【35】

> 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

🔥 技巧 🔥：

- 相比 704 二分查找，这个需要返回最后插入的位置
- 而插入的位置一定是最右侧，然后 + 1

```js
var searchInsert = function (nums, target) {
  let left = 0
  let right = nums.length - 1

  while (left <= right) {
    const mid = parseInt((left + right) / 2)
    // 比查找某个数字在数组的位置，要多一些逻辑
    // 如果不在数组中，则如此：nums[pos-1]<target<num[pos]
    if (nums[mid] === target) {
      return mid
    } else if (nums[mid] > target) {
      right = mid - 1
    } else {
      // 此时target大于中位数的值，左侧一半都没有用
      left = mid + 1
    }
  }
  // 最后返回right
  return right + 1
}
```

#### 排序数组中查找元素的第一个和最后一个位置【34】

> 给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。请你找出给定目标值在数组中的开始位置和结束位置。
> 如果数组中不存在目标值 target，返回 [-1, -1]。
> 你必须设计并实现时间复杂度为 O(log n) 的算法解决此问题。

🔥 技巧 🔥：

- 非递减顺序，那肯定是递增吗？这里可以认为是
- 想象在一个递增序列里，然后给定一个数字，返回这个数字在数组中，出现最开始以及结尾的位置
- 左右两个指针，向中间靠拢？

#### 69. x 的平方根

- 给定一个数字，不要使用内置函数，求其平方根，保留整数
- 将数字想象成序列，从 1...n，然后利用二分法，判断 `mid*mid` 与 x 的值的关系
- 最后返回右指针的大小

#### 367. 有效的完全平方数

- 给定一个数字，不要使用内置函数，判断其平方根是否为整数，如果为整数则是完全平方数
- 利用二分法，注意这里二分法，不能只取 `Math.floor((left+right)/2)` 一次
- 比如 16 =》 (16+0)/2 = 8 还需要多次二分法

### 移除元素

#### 1047. 删除字符串中的所有相邻重复项

- "abbaca" -> 'ca'
- `for of` 或者 `for` 循环遍历，然后对比栈顶元素 与 当下正在循环的元素
- 满足条件则删除栈顶元素，否则压入栈

```js
var removeDuplicates = function (s) {
  const stk = []
  //  也可以使用for 循环
  for (const ch of s) {
    if (stk.length && stk[stk.length - 1] === ch) {
      stk.pop()
    } else {
      stk.push(ch)
    }
  }
  // 对于844题，则这里还需要过滤 多余的 #
  return stk.join('')
}
```

#### 27. 移除重复的值

- 给定一个数组和一个值 val，然后移除数组中所有等于 val 的元素，并返回移除后数组长度
- 利用两个指针，一个指针 right 用来遍历所有的，过滤满足条件的，一个指针 left 用来存储满足条件的
- 然后最后的长度，其实就是 left

> 给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。
> 不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。
> 元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。

🔥 技巧 🔥：

- 双指针，一个指针在前面过滤满足条件的，另外一个指针记录有效的值

```js
var removeElement = function (nums, val) {
  // 利用双指针，方法妙啊，一个指针在前面走，然后遍历满足条件的，然后赋值
  const n = nums.length
  let left = 0

  for (let right = 0; right < n; right++) {
    if (nums[right] !== val) {
      nums[left] = nums[right]
      left++
    }
  }
  // 此时数组可能还是会多余几项，如果想干掉的话，则需要操作数组，删除left长度后面的数据
  // 但还有个技巧，就是直接返回left的值
  return left
}
```

#### 26. 删除有序数组中的重复项

- 对比 27 题，这里的重复是数组内，相邻元素重复，而且是递增序列
- 同样利用双指针，条件是相邻元素

> 给你一个 非严格递增排列 的数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。元素的 相对顺序 应该保持 一致 。然后返回 nums 中唯一元素的个数。

🔥 技巧 🔥：

- 这里有个前提，是递增
- 双指针，一个指针在前面过滤满足条件的，另外一个指针记录有效的值
- 从 0 开始，可以避免很多问题

```js
var removeDuplicates = function (nums) {
  let left = 0

  for (let right = 0; right < nums.length; right++) {
    // 如果挨着的两个
    if (nums[right] !== nums[right + 1]) {
      nums[left] = nums[right]
      left++
    }
  }
  return left
}
```

#### 283. 移动零

- 给定一个数组，将所有 0 移到末尾，其他数字顺序不变
- 利用双指针，只移动非零的，此时剩下的还有数字，需要基于 left 将后面的重置为 0
- 还有一个不需要重置的方法，遇到非零的，就交换位置`[nums[left], nums[right]] = [nums[right], nums[left]]`

#### 844. 比较含退格的字符串

- 给你两个字符串，字符串内部后退删除键用#号代替，一个删除键可以删除前面的一个字符，试问最后两个字符串是否相同
- 这两个字符串，因为有删除键，类似消消乐，因此刚开始的长度可能不一致，但经过删除后，长度一致，因此需要分开遍历
  - 比如 `"xywrrmu#p", "xywrrmp"`
- 经过删除处理后，还可能形成没有成对的情况，比如 `p, #p`，因此还需对栈进行过滤
- 类似删除一个字符串或者数组中，满足一定条件的字符场景，切记：是栈顶元素与待处理元素之间的对比
  - 参考：1047. 删除字符串中的所有相邻重复项

#### 977. 有序数组的平方

- 给你一个递增的数字数组，返回也是递增的数字平方数组
  - 注意刚开始的数组有可能有负值，而平方后就变成了正值 `[-4,-1,0,3,10] -> [16,1,0,9,100]`
  - 因此需要排序
- 这是在考察什么？
  - 绝对值排序，然后平方？
  - 平方，然后排序？
  - `nums.map(item => Math.abs(item)*Math.abs(item)).sort((x,y) => x - y)` 复杂度为 ` O(n + nlogn)`
- 复杂度：O(n)
  - 利用双指针，仔细观察，绝对值最大的值，一定在两侧，因此利用左右指针遍历数组，然后再用另外一个数组取承载结果
  - 另外 负负得正
  - 类似之前 1047，新建一个堆栈去承载结果

### 长度最小的子数组

#### 209.长度最小的子数组

- 给定一个整数数组和 target，找出该数组中连续数字和大于 target 的最小数量
- 利用滑动窗口

```js
var minSubArrayLen = function (target, nums) {
  let res = 0 // 记录结果
  let left = 0
  let minLen = Infinity
  let right = 0 // 指针一直向右移动

  while (right < nums.length) {
    if (res < target) {
      res += nums[right]
      right++
    } else {
      minLen = Math.min(right - left, minLen)
      res -= nums[left]
      left++
    }
  }

  // 这里还需要检查最后一个，为什么之前最长无重复字符串不需要。。。。？
  // 不一样，这里主要是right++后，不满足while循环了，导致可能会漏掉最后一种情况
  // 检查最后一个窗口
  while (res >= target) {
    minLen = Math.min(right - left, minLen)
    res -= nums[left]
    left++
  }

  return minLen === Infinity ? 0 : minLen
}

// 优化版本
var minSubArrayLenPro = function (target, nums) {
  let res = 0 // 记录结果
  let left = 0
  let minLen = Infinity
  let right = 0 // 指针一直向右移动

  while (right < nums.length) {
    // 上来就累加
    res += nums[right]
    right++
    // 加完就判断
    while (res >= target) {
      minLen = Math.min(right - left, minLen)
      res -= nums[left]
      left++
    }
  }

  return minLen === Infinity ? 0 : minLen
}
```

### 螺旋矩阵

#### 59.螺旋矩阵 II

## 链表

### 移除链表元素

#### 203. 移除链表元素

- 给一个链表的头结点 head 和一个整数 val，删除所有节点值是 val 的节点，并返回头结点
- 头结点的值，也可能是目标值，但头结点没有父节点，因此删除头结点的方式，因为链表的其他节点都是通过前一个节点来移除当前节点，而头结点没有前一个节点，只能向后移动实现删除
  - 为了与普通节点删除的方式保持一致，可以新建一个虚拟节点，然后虚拟节点指向这个头结点
- 新建的节点假如指向了 headA，那后续操作时，则需要一个临时指针去操作，即 `let temp = headA`，
  - 想象一列火车，如果想去掉中间几节，是不是车头一直不动，然后找个人（指针）操作某些节点实现？

```js
var removeElements = function (head, val) {
  // 有可能 head.val就等于val，这里创建一个头结点，并把head挂上去，肯定就不会出现这种情况了
  // const dummyHead = new ListNode(0)
  // dummyHead.next = head

  // // 赋值给另外一个指针，遍历这个指针
  // let temp = dummyHead

  // 还可以如下，一步到位
  const ret = new ListNode(0, head)

  let temp = ret
  // 移除头结点和移除其他节点的操作是不一样的，因为链表的其他节点都是通过前一个节点来移除当前节点，而头结点没有前一个节点。
  // 所以头结点如何移除呢，其实只要将头结点向后移动一位就可以，这样就从链表中移除了一个头结点。

  // 这样移除了一个头结点，是不是发现，在单链表中移除头结点 和 移除其他节点的操作方式是不一样，其实在写代码的时候也会发现，需要单独写一段逻辑来处理移除头结点的情况。

  // 那么可不可以 以一种统一的逻辑来移除 链表的节点呢。
  // 其实可以设置一个虚拟头结点，这样原链表的所有节点就都可以按照统一的方式进行移除了。也就是上面的 new ListNode(0, head)
  while (temp.next !== null) {
    if (temp.next.val === val) {
      temp.next = temp.next.next
    } else {
      temp = temp.next
    }
  }
  // 遍历使用的temp，而最终返回的使用的 ret
  // 因为ret.next指向一直不会变，而利用一个游动的指针temp不停的操作这个链表，从而实现切割
  return ret.next
}
```

### 设计链表

- 链表内部使用 size 统计链表长度，可以快速做一些边界处理

### 反转链表

#### 206. 反转链表

- 迭代法
  - 先定义一个临时指针 `let pre = null`
  - 然后定义一个 游动指针 `let cur = head`
- 递归法
  - 退出条件：链表为空或者只有一个节点 `head === null || head.next === null`
  -

#### 24. 两两交换链表中的节点

- 迭代法
  - 新建虚拟节点
  - 用两个临时变量存储，然后交换位置，方便理解
- 递归法
  - 需要多多练习

#### 19. 删除链表的倒数第 N 个结点

- 这种操作倒数 n 的问题，可以使用 快慢指针
- 快指针先走 n 步，然后快慢指针一块走，等到快指针走到头，慢指针的指向就是目标了

#### 160. 相交链表

- 判断两个链表是否有交点
- 先分别遍历两个链表，然后统计出两个的长度，然后让长的先走 `len1- len2` 步，
- 此时二者节点相对于尾部应该对齐了，然后再挨个对比，一块向后走
- 最后返回任意节点，如果该节点为 null，说明没有相交

#### 142. 环形链表 II

- 给定一个链表，如果是环形链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。
- 判断环形链表
  - 快慢指针判断是否有环，如果有环必定在环内相遇，因为可以理解为在环内，快指针在慢慢的靠近慢指针，因此一定相遇
- 如何计算 链表开始入环的第一个节点
  - 假设从头结点到环形入口节点 的节点数为 x，环形入口节点到 fast 指针与 slow 指针相遇节点 节点数为 y，从相遇节点 再到环形入口节点节点数为 z，想象一根绳一段绕在一根很粗的柱子上，然后另一端一个人扯着
    - 人扯着的地方到绳与柱子接触的地方为入口

那么相遇时： slow 指针走过的节点数为: x + y， fast 指针走过的节点数：x + y + n (y + z)，n 为 fast 指针在环内走了 n 圈才遇到 slow 指针， （y+z）为一圈内节点的个数 A。

因为 fast 指针是一步走两个节点，slow 指针一步走一个节点， 所以 fast 指针走过的节点数 = slow 指针走过的节点数 \* 2：

`(x + y) * 2 = x + y + n (y + z)`

两边消掉一个`（x+y）: x + y = n (y + z)`

因为要找环形的入口，那么要求的是 x，因为 x 表示 头结点到 环形入口节点的的距离。

所以要求 x ，将 x 单独放在左面：`x = n (y + z) - y` ,

再从 n(y+z) 中提出一个（y+z）来，整理公式之后为如下公式：`x = (n - 1) (y + z) + z` 注意这里 n 一定是大于等于 1 的，因为 fast 指针至少要多走一圈才能相遇 slow 指针。

这个公式说明什么呢？

先拿 n 为 1 的情况来举例，意味着 fast 指针在环形里转了一圈之后，就遇到了 slow 指针了。

当 n 为 1 的时候，公式就化解为 x = z，

这就意味着，从头结点出发一个指针，从相遇节点 也出发一个指针，这两个指针每次只走一个节点， 那么当这两个指针相遇的时候就是 环形入口的节点。

也就是在相遇节点处，定义一个指针 index1，在头结点处定一个指针 index2。

让 index1 和 index2 同时移动，每次移动一个节点， 那么他们相遇的地方就是 环形入口的节点。

那么 n 如果大于 1 是什么情况呢，就是 fast 指针在环形转 n 圈之后才遇到 slow 指针。

其实这种情况和 n 为 1 的时候 效果是一样的，一样可以通过这个方法找到 环形的入口节点，只不过，index1 指针在环里 多转了(n-1)圈，然后再遇到 index2，相遇点依然是环形的入口节点。

## hash

如果在**遇到需要判断一个元素是否出现过的场景也应该第一时间想到哈希法**！

三种哈希结构：

- 数组
- set（集合）
- map（映射）

### 350. 两个数组的交集 II

- 给定两个数组，返回这两个数组中都有的元素组成的数组，要求出现次数以两个数组中小值为准
- 遍历一个数组，记录每个元素出现的次数
- 然后再遍历另外一个数组，然后遍历到后，次数都减一，如果最后减到 0，则该数字不行

### 202. 快乐数

- 给定一个整数，每一次将该数替换为它每个位置上的数字的平方和。如果最后结果是 1，则是快乐数
- 有可能是死循环，也就不是一个快乐数，因此如何避开死循环也是个技巧
- 利用快慢指针思想，慢指针是每次生成的数，而快指针是生成两次的，看是否相交以及 fast 是否为 1，
  - 不像交 且 不等于 1，则一直循环，如果相交则意味着死循环了，
  - 最后判断值是否等于 1

```
输入：n = 19
输出：true
解释：
12 + 92 = 82
82 + 22 = 68
62 + 82 = 100
12 + 02 + 02 = 1
```

```js
var isHappy = function (n) {
  // 可以利用链表，而且是快慢指针判断是否有环，每次新产生的数字，都可以理解为快指针
  const getNext = (n) =>
    n
      .toString()
      .split('')
      .map((i) => i ** 2)
      .reduce((cur, acc) => acc + cur)

  let slow = n
  let fast = getNext(n)

  // 如果快指针不等于1，且二者不相等，则一直循环，直到相交，相交意味着死循环了
  while (fast !== 1 && fast !== slow) {
    slow = getNext(slow)
    fast = getNext(getNext(fast))
  }
  return fast === 1
}
```

### 1. 两数之和

- 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。
- 凡是查找是否出现过这样的，都可以使用 hashmap
- 两数之和也是同样道理，将 `rest = target - nums[i]` 存入 map，然后遍历 `nums[i]` 并检查 `map.has(rest)` 即可找到

### 454. 四数相加 II

- 给你四个整数数组 nums1、nums2、nums3 和 nums4 ，数组长度都是 n ，请你计算有多少个元组 (i, j, k, l) 能满足：`nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0`
- 参考两数之和，如果将这里的两个数的和，作为一个整体存到 map 中，然后再把剩下的两个也作为一个整体遍历，是不是顿时就变成两数之和了？
- 那其他的三数之和，四数字和都可以这样吗？？

### 383. 赎金信

- 给定两个小写的字符串，判断一个字符串里的字符是否完全在另外一个里面找到。

### 15. 三数之和

【题：】给你一个整数数组 nums ，判断是否存在三元组 `[nums[i], nums[j], nums[k]]` 满足 `i != j、i != k 且 j != k` ，同时还满足 `nums[i] + nums[j] + nums[k] == 0 `，请返回所有和为 0 且不重复的三元组。

思路：

首先将数组排序，然后一层 for 循环，i 从下标 0 的地方开始，同时定一个下标 left 定义在 i+1 的位置上，定义下标 right 在数组结尾的位置上。

依然还是在数组中找到 abc 使得`a + b +c =0`，我们这里相当于 `a = nums[i]，b = nums[left]，c = nums[right]`

接下来如何移动 left 和 right 呢， 如果 `nums[i] + nums[left] + nums[right] > 0` 就说明 此时三数之和大了，因为数组是排序后了，所以 right 下标就应该向左移动，这样才能让三数之和小一些。

如果 `nums[i] + nums[left] + nums[right] < 0` 说明 此时 三数之和小了，left 就向右移动，才能让三数之和大一些，直到 left 与 right 相遇为止。

如何去重呢？

说到去重，其实主要考虑三个数的去重。 a, b ,c, 对应的就是 `nums[i]，nums[left]，nums[right]`

a 如果重复了怎么办，a 是 nums 里遍历的元素，那么应该直接跳过去。

但这里有一个问题，是判断 `nums[i] 与 nums[i + 1]` 是否相同，还是判断 `nums[i] 与 nums[i-1]` 是否相同。

```js
// ❌ 不应该
// 例如{-1, -1 ,2} 这组数据，当遍历到第一个-1 的时候，判断 下一个也是-1，那这组数据就pass了。是不应该的
if (nums[i] == nums[i + 1]) { // 去重操作
    continue;
}

// ✅ 应该
if (i > 0 && nums[i] == nums[i - 1]) {
    continue;
}
```

b 与 c 的去重呢？

很多同学写本题的时候，去重的逻辑多加了 对 right 和 left 的去重：（代码中注释部分）

```js
while (right > left) {
  if (nums[i] + nums[left] + nums[right] > 0) {
    right--
    // 去重 right
    while (left < right && nums[right] == nums[right + 1]) right--
  } else if (nums[i] + nums[left] + nums[right] < 0) {
    left++
    // 去重 left
    while (left < right && nums[left] == nums[left - 1]) left++
  } else {
  }
}
```

拿 right 去重为例，即使不加这个去重逻辑，依然根据 `while (right > left) 和 if (nums[i] + nums[left] + nums[right] > 0) 去完成right-- ` 的操作。

多加了 `while (left < right && nums[right] == nums[right + 1]) right--;` 这一行代码，其实就是把 需要执行的逻辑提前执行了，但并没有减少 判断的逻辑。

- 🔥 注意：虽然三数之和可以使用双指针，但是两数之和就不行，因为三数之和不关心顺序，还经过了排序

```js
var threeSum = function (nums) {
  // 原理：先排序，然后定义两个指针 left,right，left的位置是 i + 1, 而right的位置在最右侧
  // 也就是判断 nums[i] + nums[left] + nums[right] 与 0 的关系
  // 如果大于0，说明值大了，right指针--，反之调整left，然后这样循环
  // 然后将满足条件的值，放在数组中
  // 那循环完，如何去重呢？
  const res = []
  nums = nums.sort((x, y) => x - y)

  // 排序后，如果第一个就大于0，那直接就是空数组
  if (nums[0] > 0) return []

  for (let i = 0; i < nums.length; i++) {
    let left = i + 1
    let right = nums.length - 1

    // 需要对第一个数去重
    if (nums[i] === nums[i - 1]) {
      continue
    }

    // 也就是一个i，对应一个while循环
    while (left < right) {
      const sum = nums[i] + nums[left] + nums[right]
      if (sum === 0) {
        res.push([nums[i], nums[left], nums[right]])
        // 上面的状态已经满足条件了，那下一个left或者right如果值等于当前的这个，是不是就没有意义了
        // 所以可以干掉重复的
        while (left < right && nums[left] === nums[left + 1]) left++
        while (left < right && nums[right] === nums[right - 1]) right--

        // 上面两个while循环仅仅将指针移到了下一个依然重复的数值上了，下面仍然需要移动指针，
        // 这样才可以移动到不重复的指针上
        left++
        right--
      } else if (sum < 0) {
        left++
      } else {
        right--
      }
    }
  }
  // 到这里拿到了所有的结果，如何去重
  return res
}
```

### 18. 四数之和

【题：】给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c + d 的值与 target 相等？找出所有满足条件且不重复的四元组。

```js
var fourSum = function (nums, target) {
  // 这里的复杂性在于去重，之前处理过 15 题，三数之和，一个for循环，两个指针
  // 而这里则需要双重循环，然后继续配合left，right指针
  // 同时退出的条件，也与之前排序后 nums[0] > 0 就返回 [] 不同

  let len = nums.length
  const res = []
  nums = nums.sort((a, b) => a - b)

  // 排序后，第一个都大于target直接返回空
  if (nums[0] > target) return []

  for (let i = 0; i < len; i++) {
    // 对nums[i]去重
    if ([nums[i] === nums[i - 1]]) continue

    for (let j = i + 1; j < len; j++) {
      // 对nums[j]去重
      if ([nums[j] === nums[j - 1]]) continue

      // 两层for循环，再加两个指针
      let left = j + 1
      let right = nums[len - 1]

      while (left < right) {
        const sum = nums[i] + nums[j] + nums[left] + nums[right]
        if (sum > target) {
          right--
        } else if (sum < target) {
          left++
        } else {
          res.push(nums[i], nums[j], nums[left], nums[right])
          // 对两个指针去重
          while (left < right && nums[left] === nums[left + 1]) left++
          while (left < right && nums[right] === nums[right - 1]) right++
          // 继续移动指针到不重复的元素上
          left++
          right--
        }
      }
    }
  }

  return res
}
```

### hash 题目总结

一些应用场景就是为数组量身定做的。

在 242.有效的字母异位词 (opens new window)中，我们提到了数组就是简单的哈希表，但是数组的大小是受限的！

这道题目包含小写字母，那么使用数组来做哈希最合适不过。

在 383.赎金信 (opens new window)中同样要求只有小写字母，那么就给我们浓浓的暗示，用数组！

本题和 242.有效的字母异位词 (opens new window)很像，242.有效的字母异位词 (opens new window)是求 字符串 a 和 字符串 b 是否可以相互组成，在 383.赎金信 (opens new window)中是求字符串 a 能否组成字符串 b，而不用管字符串 b 能不能组成字符串 a。

一些同学可能想，用数组干啥，都用 map 不就完事了。

上面两道题目用 map 确实可以，**但使用 map 的空间消耗要比数组大一些，因为 map 要维护红黑树或者符号表，而且还要做哈希函数的运算。所以数组更加简单直接有效**！

## 字符串

### 344. 反转字符串

- 给定一个字符串，反转下
- 双指针，向内部移动，同时换位

### 541. 反转字符串 II

【题：】给定一个字符串 s 和一个整数 k，从字符串开头算起，每计数至 2k 个字符，就反转这 2k 字符中的前 k 个字符。

- 如果剩余字符少于 k 个，则将剩余字符全部反转。
- 如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。

其实仔细分析，其实就是将字符串，每 2k 一个分组，然后将每组内的前 k 个进行换位置。

当需要固定规律一段一段去处理字符串的时候，要想想在在 for 循环的表达式上做做文章。

```js
var reverseStr = function (s, k) {
  // 仔细分析题目，其实就是将字符串分成很多组，每组都是 2k个
  // 然后每次都反转这一组的前k个
  // 所以当需要固定规律一段一段去处理字符串的时候，要想想在在for循环的表达式上做做文章。
  let len = s.length
  let resArr = s.split('')

  for (let i = 0; i < len; i += 2 * k) {
    // 当k为2时，也就是0-4，反转索引0,1
    // 定义两侧指针，分别是开始和结束位置
    let left = i
    let right = i + k - 1 > len ? len : i + k - 1

    while (left < right) {
      // 换位置
      ;[resArr[left], resArr[right]] = [resArr[right], resArr[left]]
      left++
      right--
    }
  }
  return resArr.join('')
}
```

### LCR 122. 路径加密

【题：】假定一段路径记作字符串 path，其中以 "." 作为分隔符。现需将路径加密，加密方法为将 path 中的分隔符替换为空格 " "，请返回加密后的字符串。

- 注意这里不是简单的，使用正则 replace 而已
- 这里是挨个操作字符，
- 想象下：两个指针，都从右侧开始向左遍历，利用一个覆盖另外一个，最后返回指定长度的

```js
var pathEncryption = function (path) {
  // 如果简单的使用工具方法就太简单了，这里需要直接操作字符串
  // 将字符串转成数组，然后再将指定字符换算成其他字符，
  const strArr = Array.from(path)
  let count = 0

  // 计算 . 的数量，根据其数量，后续换成其他长度的符号
  for (let i = 0; i < strArr.length; i++) {
    if (strArr[i] === '.') {
      count++
    }
  }

  // 定义两个指针
  // left 是原来数组的末尾
  // right 是替换后数组的末尾
  let left = strArr.length - 1
  // 一个空格占用一个空间，如果多个的话，count 需要乘以倍数
  let right = strArr.length + count - 1

  // 这里面的思想就是，利用两个指针，一遍遍历一遍覆盖
  while (left >= 0) {
    if (strArr[left] === '.') {
      strArr[right--] = ' '
      left--
    } else {
      strArr[right--] = strArr[left--]
    }
  }

  // 这里先截取有效的，然后再拼接
  return strArr.slice(right + 1).join('')
}
```

## 栈和队列

- 队列是先进先出，想象排队打饭
- 栈是先进后出

### 232. 用栈实现队列

- 栈的方法只有 push，和 pop，也就是说只能使用 栈的 pop 和 push 去实现队列
- 而队列有 push（插到队尾），pop（从队列的开头移除并返回元素），peek（返回队列开头的元素）
  - 也就是说：队列只能一头进，一头出
- 利用两个数组，来回倒腾即可

### 225. 用队列实现栈

- 队列的方法，上面说过，只能一头进，一头出
- 这里实现栈，而栈则只能在一头又进，又出

```js
var MyStack = function () {
  // 站的几种操作
  // push 将元素 x 压入栈顶
  // pop 移除并返回栈顶元素
  // top 返回栈顶元素
  // empty 判断栈是否为空
  this.queue = []
}

/**
 * @param {number} x
 * @return {void}
 */
MyStack.prototype.push = function (x) {
  // 队列只能一头进，一头出，push是一头进
  // 然后 shift 就是一头出
  this.queue.push(x)
}

/**
 * @return {number}
 */
MyStack.prototype.pop = function () {
  let size = this.queue.length
  // 当size大于1才可以
  while (size-- > 1) {
    // 从前面弹出，然后再从后面压入
    // 想象一下，队列是先进先出，也就是说只能一头进，一头出
    this.queue.push(this.queue.shift())
  }
  return this.queue.shift()
}

/**
 * @return {number}
 */
MyStack.prototype.top = function () {
  const x = this.pop()
  this.queue.push(x)
  return x
}

/**
 * @return {boolean}
 */
MyStack.prototype.empty = function () {
  return !this.queue.length
}
```

### 20. 有效的括号

- 括号匹配是使用栈解决的经典问题。
- 由于栈结构的特殊性，非常适合做对称匹配类的题目。
- 如果遇到了右侧括号，则栈顶的必定是与之匹配的左侧括号，如果不是则为 false

### 1047. 删除字符串中的所有相邻重复项

- 利用栈，待匹配的元素与栈顶元素比较

### 150. 逆波兰表达式求值

- 与删除相邻重复项很像
- 这里是遇到一个符号，则弹出最近的两个数字，根据符号算出结果
- 相除操作，总是向零截断，与`Math.floor`不同，`Math.floor` 在负数场景下，是更负，而不是向 0
  - `-1 / 2 | 0 = 0` 而 `Math.floor(-1 / 2) = -1`

```js
/**
 * @param {string[]} tokens
 * @return {number}
 */
var evalRPN = function (tokens) {
  const stack = []

  for (const token of tokens) {
    // 如果不是数字，则就是运算符
    // 然后弹出两个数字，做运算
    if (isNaN(Number(token))) {
      // 注意这里有顺序，先弹出来的是n2，后弹出来的是n1
      const n2 = stack.pop()
      const n1 = stack.pop()

      switch (token) {
        case '+':
          stack.push(n1 + n2)
          break
        case '-':
          stack.push(n1 - n2)
          break
        case '*':
          stack.push(n1 * n2)
          break
        case '/':
          // 与 0 做位运算，其实就是舍弃小数，只保留整数，
          // 注意这里面，不能是用Math.floor，因为在负数场景下，Math.floor是更负
          stack.push((n1 / n2) | 0)
          // console.log(n1/n2 | 0, Math.floor(n1 / n2), n1/n2)
          // stack.push(Math.floor(n1 / n2))
          break
      }
    } else {
      stack.push(Number(token))
    }
  }
  return stack[0]
}
```

### 239. 滑动窗口最大值

## 二叉树

- 二叉树的遍历方式
  - 前序遍历
  - 后续遍历
  - 中序遍历
  - 层序遍历
- 二叉树的属性
- 二叉树的修改与构造
- 求二叉搜索树的属性
- 二叉树公共祖先问题
- 二叉搜索树的修改与构造

### 二叉树的类型

#### 满二叉树

- 在二叉树中，度（degree）是指一个节点拥有的子节点（孩子节点）的个数。对于二叉树的节点来说，度的取值范围可以是 0、1 或 2。
- 如果一棵二叉树只有度为 0 的结点和度为 2 的结点，并且度为 0 的结点在同一层上，则这棵二叉树为满二叉树
- 深度为 k，有 2^k-1 个节点的二叉树

#### 完全二叉树

在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层（h 从 1 开始），则该层包含 1~ 2^(h-1) 个节点。

#### 二叉搜索树

- 前面介绍的树，都没有数值的，而二叉搜索树是有数值的了，二叉搜索树是一个有序树。
  - 若它的左子树不空，则左子树上**所有结点的值均小于它的根结点的值**；
  - 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
  - 它的左、右子树也分别为二叉排序树

#### 平衡二叉搜索树

平衡二叉搜索树：又被称为 AVL（Adelson-Velsky and Landis）树，且具有以下性质：

- 它是一棵空树或它的左右两个子树的高度差的绝对值不超过 1，
- 并且左右两个子树都是一棵平衡二叉树。

### 二叉树的存储方式

- 二叉树可以链式存储，也可以顺序存储。
- 那么链式存储方式就用指针， 顺序存储的方式就是用数组。

```js
// 下面是用数组来存储二叉树
//          a
//        /   \
//       b     c
//      / \   / \
//     d   e  f  g

// 数组中的树：a b c d e f g
//      下标：0 1 2 3 4 5 6
```

那如何遍历呢？

如果父节点为 i，那么他的左孩子结点：`i * 2 + 1`，右孩子节点：`i * 2 + 2`

比如 b 是父节点，索引就是 1， 那孩子节点就是 3,4

但是用链式表示的二叉树，更有利于我们理解，所以一般我们都是用链式存储二叉树。

### 二叉树的遍历方式

- 深度优先：先往深走，遇到叶子节点再往下走
  - 前序遍历（递归法，迭代法）
  - 中序遍历（递归法，迭代法）
  - 后序遍历（递归法，迭代法）
- 广度优先：一层一层的遍历
  - 层次遍历（迭代法）

前中后，其实指的就是中间节点的遍历顺序

- 前序遍历：中左右 ，下图：a b d e c f g
- 中序遍历：左中右 ，下图：d b e a f c g
- 后序遍历：左右中 ，下图：d e b f g c a

```js
//          a
//        /   \
//       b     c
//      / \   / \
//     d   e  f  g

// 对比链表，二叉树的数据结构多了一个指针
function TreeNode(val, left, right) {
  this.val = val === undefined ? 0 : val
  this.left = left === undefined ? null : left
  this.right = right === undefined ? null : right
}
```

### 二叉树的递归遍历

**递归就是循环嘛，都有循环主体（代码块）、循环变量（对递归来说就是参数）、终止条件。抽象一下都是一直做某事、每次变一点、直到某个条件，遇到递归题就用循环思路解**

为什么：一看就会，一写就废，因为 主要是对递归不成体系，没有方法论，每次写递归算法 ，都是靠玄学来写代码，代码能不能编过都靠运气。

首先一定要确保三要素：

1. 确定递归函数的参数和返回值
   1. 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。
2. 确定终止条件
   1. 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。
3. 确定单层递归的逻辑
   1. 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。

### 二叉树的迭代遍历

为什么写的前序遍历的代码，不能和中序遍历通用呢，因为前序遍历的顺序是中左右，先访问的元素是中间节点，要处理的元素也是中间节点，所以刚刚才能写出相对简洁的代码，因为要访问的元素和要处理的元素顺序是一致的，都是中间节点。

而中序遍历，**先访问的是二叉树顶部的节点，然后一层一层向下访问，直到到达树左面的最底部，再开始处理节点（也就是在把节点的数值放进 result 数组中）**，这就造成了处理顺序和访问顺序是不一致的。

- 注意：这里访问和处理，访问是传入的节点，不论前中后，首先访问的都是顶部节点，也就是中
- 处理：就是将值放到 res 书中
- 而除了前序排序（中左右），其他 case 下，刚开始访问和处理的都不是同一个

二叉树前中后统一代码格式：

```js
// 统一代码格式，类似递归，稍微调整下顺序，就可以满足各种条件的遍历
var postorderTraversal = function (root) {
  const res = []
  const stack = []

  root && stack.push(root)
  while (stack.length) {
    // 后序遍历：左右中
    // 压栈顺序：中右左
    const node = stack.pop() // 弹出栈顶
    if (!node) {
      // 如果是空节点，则下一个节点是要处理的节点，也就是要赋值的节点
      res.push(stack.pop().val)
      continue // 继续判断
    }
    // 等到所有的节点都处理完了，则开始压入新一轮的节点
    stack.push(node)
    stack.push(null)
    node.right && stack.push(node.right)
    node.left && stack.push(node.left)
  }

  return res
}
```

### 二叉树的层序遍历

- 队列先进先出，符合一层一层遍历的逻辑，
- 而用栈先进后出适合模拟深度优先遍历也就是递归的逻辑。
- 而这种层序遍历方式就是图论中的广度优先遍历，只不过我们应用在二叉树上。

#### 102. 二叉树的层序遍历

- 其实就是利用队列，没遍历一个节点，都会把其子节点放入进去

## 回溯

回溯是递归的副产品，只要有递归就会有回溯。回溯函数也就是递归函数，指的都是一个函数。

回溯法的效率，回溯法并不是什么高效的算法。

因为回溯的本质是穷举，穷举所有可能，然后选出我们想要的答案，如果想让回溯法高效一些，可以加一些剪枝的操作，但也改不了回溯法就是穷举的本质。

为什么用回溯? 因为没得选 一些问题能暴力搜出来就不错了，撑死了再剪枝一下，还没有更高效的解法。

回溯法，一般可以解决如下几种问题：

- 组合问题：N 个数里面按一定规则找出 k 个数的集合
- 切割问题：一个字符串按一定规则有几种切割方式
- 子集问题：一个 N 个数的集合里有多少符合条件的子集
- 排列问题：N 个数按一定规则全排列，有几种排列方式
- 棋盘问题：N 皇后，解数独等等

回溯法解决的问题都可以抽象为树形结构，是的，我指的是所有回溯法的问题都可以抽象为树形结构！

因为回溯法解决的都是在**集合中递归查找子集，集合的大小就构成了树的宽度，递归的深度，都构成的树的深度**。

递归就要有终止条件，所以必然是一棵高度有限的树（N 叉树）。

```js
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    // for循环以及递归的遍历，就如下图
    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
```

- for 循环就是遍历集合区间，可以理解一个节点有多少个孩子，这个 for 循环就执行多少次。
- backtracking 这里自己调用自己，实现递归。
- for 循环可以理解是横向遍历，backtracking（递归）就是纵向遍历，这样就把这棵树全遍历完了
  ![图示](https://code-thinking-1253855093.file.myqcloud.com/pics/20210130173631174.png)

### 组合问题

给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合。

示例: 输入: n = 4, k = 2 输出: [ [2,4], [3,4], [2,3], [1,2], [1,3], [1,4], ]

```c++
// 两层for循环
int n = 4;
for (int i = 1; i <= n; i++) {
    for (int j = i + 1; j <= n; j++) {
        cout << i << " " << j << endl;
    }
}

// 如果是n = 100, k = 3 那么就三层for循环，代码如下：
int n = 100;
for (int i = 1; i <= n; i++) {
    for (int j = i + 1; j <= n; j++) {
        for (int u = j + 1; u <= n; n++) {
            cout << i << " " << j << " " << u << endl;
        }
    }
}
```

那如果 n 为 100，k 为 50 呢，那就 50 层 for 循环，是不是开始窒息。。。此时就会发现虽然想暴力搜索，但是用 for 循环嵌套连暴力都写不出来！

咋整？

回溯搜索法来了，虽然回溯法也是暴力，但至少能写出来，不像 for 循环嵌套 k 层让人绝望。

那么回溯法怎么暴力搜呢？

上面我们说了要解决 n 为 100，k 为 50 的情况，暴力写法需要嵌套 50 层 for 循环，那么回溯法就用递归来解决嵌套层数的问题。

递归来做层叠嵌套（可以理解是开 k 层 for 循环），每一次递归中就嵌套一个 for 循环，那么递归就可以用于解决多层嵌套循环的问题了。

此时递归的层数大家应该知道了，例如：n 为 100，k 为 50 的情况下，就是递归 50 层。

说到回溯法解决的问题都可以抽象为树形结构（N 叉树），用树形结构来理解回溯就容易多了。如下图：

![合问题抽象为如下树形结构](https://code-thinking-1253855093.file.myqcloud.com/pics/20201123195223940.png)

可以看出这棵树，一开始集合是 1，2，3，4， 从左向右取数，取过的数，不再重复取。

第一次取 1，集合变为 2，3，4 ，因为 k 为 2，我们只需要再取一个数就可以了，分别取 2，3，4，得到集合[1,2] [1,3] [1,4]，以此类推。

每次从集合中选取元素，可选择的范围随着选择的进行而收缩，调整可选择的范围。

图中可以发现 n 相当于树的宽度，k 相当于树的深度。

#### 剪枝优化

我们说过，回溯法虽然是暴力搜索，但也有时候可以有点剪枝优化一下的。

来举一个例子，n = 4，k = 4 的话，那么第一层 for 循环的时候，从元素 2 开始的遍历都没有意义了。 在第二层 for 循环，从元素 3 开始的遍历都没有意义了。

![](https://code-thinking-1253855093.file.myqcloud.com/pics/20210130194335207-20230310134409532.png)

所以，可以剪枝的地方就在递归中每一层的 for 循环所选择的起始位置。

如果 for 循环选择的起始位置之后的元素个数 已经不足 我们需要的元素个数了，那么就没有必要搜索了

```js
var combine = function (n, k) {
  // 如果k很小的，可以利用多层循环，暴力解决，但是现在k不确定，所以暴力解决就无效

  const res = [] // 存放结果的数组

  // 定义回溯函数
  function backtrack(start, current) {
    // 如果满足条件了，就将当前组合放入到结果列表
    if (current.length === k) {
      res.push(current.slice()) // 每次产生一个
      return // 结束，开始向后退
    }

    // 还可以再优化下，因为随着回溯backtrack的执行
    // 其实后面i可以取值的范围越来越小
    for (let i = start; i <= n - (k - current.length) + 1; i++) {
      current.push(i) // 将数字加入组合，
      backtrack(i + 1, current) // 上面i已经加入了，那这里就需要从i+1开始
      current.pop() // 后退
    }
  }

  // 执行，一般传入开始位置，path路径
  // 1 是因为，规定的范围是 [1, n]，最小就是1
  // 刚开始路径就是[]
  backtrack(1, []) //

  return res
}
```

### 组合综合
